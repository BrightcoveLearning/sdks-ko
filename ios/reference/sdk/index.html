<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>iOS 참조용 Brightcove 기본 플레이어</title>

	<link rel="stylesheet" href="css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title"> <a href="index.html">Brightcove Native Player for iOS </a> </h1>

			<p id="developer-home">
				<a href="index.html">브라이트코브</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="hierarchy.html">계층</a></li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview-contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">iOS 참조용 Brightcove 기본 플레이어</h1>

					
					<div class="section section-overview index-overview">
						
						
						<h1>iOS용 Brightcove 플레이어 SDK, 버전 6.9.0.1697</h1><h1>목차</h1>

<ol>
<li><a href="#Requirements">요구 사항</a></li>
<li><a href="#SupportedPlatforms">지원되는 플랫폼</a></li>
<li><a href="#Noteworthy">주목할만한</a></li>
<li><a href="#FairPlay">페어플레이</a></li>
<li><a href="#SidecarSubtitles">사이드카 자막</a></li>
<li><a href="#OfflinePlayback">오프라인 재생</a></li>
<li><a href="#Installation">설치</a></li>
<li><a href="#CocoaPods">코코아팟</a></li>
<li><a href="#ManualInstallation">수동 설치</a></li>
<li><a href="#Imports">수입품</a></li>
<li><a href="#QuickStart">빠른 시작</a></li>
<li><a href="#PlayerUI">iOS용 내장 PlayerUI 컨트롤</a></li>
<li><a href="#TVPlayer">tvOS 용 내장 TV 플레이어 컨트롤</a></li>
<li><a href="#AirPlay">에어플레이</a></li>
<li><a href="#Video360">비디오 360</a></li>
<li><a href="#ArchitecturalOverview">아키텍처 개요</a></li>
<li><a href="#PlayPauseSeek">재생, 일시 중지 및 탐색</a></li>
<li><a href="#PreloadingVideos">동영상 미리 로드</a></li>
<li><a href="#SourceSelection">소스 선택(HLS, MP4, HTTP/HTTPS)</a></li>
<li><a href="#PreferredBitrate">기본 비트 전송률 설정</a></li>
<li><a href="#PlaybackInformation">콘텐츠 및 광고 재생 정보 얻기</a></li>
<li><a href="#HandlingNetworkInterruptionsAndSlowdowns">네트워크 중단 및 속도 저하 처리</a></li>
<li><a href="#Subclassing">서브클래싱</a></li>
<li><a href="#Values">가치</a></li>
<li><a href="#PlaybackService">재생 서비스를 사용하여 Brightcove 자산 검색</a></li>
<li><a href="#ViewStrategy">전략 보기</a></li>
<li><a href="#BackgroundVideo">백그라운드에서 비디오 재생</a></li>
<li><a href="#PIP">픽처 인 픽처</a></li>
<li><a href="#ThumbnailSeeking">썸네일 찾기</a></li>
<li><a href="#TrackingErrors">추적 오류</a></li>
<li><a href="#CombiningPlugins">플러그인 결합</a></li>
<li><a href="#BufferOptimization">버퍼 최적화</a></li>
<li><a href="#AVPlayerViewController">BCOVPlaybackController와 함께 AVPlayerViewController 사용</a></li>
<li><a href="#PlaybackAuthorizationService">재생 승인 서비스</a></li>
<li><a href="#VoiceOver">보이스오버 지원</a></li>
<li><a href="#ChinaDelivery">중국 배달</a></li>
<li><a href="#AVAudioSessionConfig">AVAudioSession 구성</a></li>
<li><a href="#FAQ">자주 묻는 질문</a></li>
<li><a href="#Support">지원하다</a></li>
</ol>


<h1>요구 사항<a name="Requirements"></a></h1>

<ul>
<li>엑스코드 11.0+</li>
<li>호</li>
</ul>


<h1>지원되는 플랫폼<a name="SupportedPlatforms"></a></h1>

<p>Brightcove는 다음 iOS 버전의 최신 공개 릴리스에서 최신 iOS SDK에 대한 적극적인 지원을 제공합니다.</p>

<ul>
<li>iOS 12, 13 및 14</li>
<li>tvOS 12, 13 및 14</li>
</ul>


<p>Brightcove는 다음 iOS 버전에 대한 수동 지원을 제공합니다.</p>

<ul>
<li>iOS 11.4.1</li>
<li>tvOS 11.4.1</li>
</ul>


<p>Core SDK는 아랍어(ar), 영어(en), 프랑스어(fr), 독일어(de), 일본어(ja), 한국어(ko), 스페인어(es), 중국어 간체(zh-Hans) 및 번체로 현지화되었습니다. 중국어(zh-Hant). 현지화의 이점을 얻으려면 앱도 동일한 언어 및 로케일에 대해 현지화되어야 합니다.</p>

<h1>주목할만한<a name="Noteworthy"></a></h1>

<p>모든 SDK 구성 요소(코어 및 플러그인 프레임워크)는 동일한 버전 번호로 출시됩니다. 단일 구성 요소를 업그레이드할 때 모든 구성 요소를 동일한 버전으로 업그레이드하십시오.</p>

<p><strong>CocoaPods Podspec 이름(릴리스 6.8.1 이후)</strong></p>

<p>Brightcove Player SDK 릴리스 6.8.1은<code> Brightcove-Player-FreeWheel</code>그리고<code> Brightcove-Player-Omniture</code>동적 버전을 설치하기 위한 podspecs <code> BrightcovePlayerSDK</code> . NS <code> -공전</code> podspec은 이제 의 정적 버전을 설치할 각 플러그인에 사용할 수 있습니다. <code> BrightcovePlayerSDK</code>플러그인 프레임워크 자체의 정적 버전과 함께. 플러그인의 정적 버전이 없는 경우 정적 버전의 플러그인과 함께 동적 버전이 설치됩니다. <code> BrightcovePlayerSDK</code> .</p>

<table>
<thead>
<tr>
<th>포드 사양 이름  </th>
<th>  프레임워크 유형  </th>
<th>  의존</th>
</tr>
</thead>
<tbody>
<tr>
<td>Brightcove-Player-Core </td>
<td> 동적 </td>
<td> -</td>
</tr>
<tr>
<td>Brightcove-Player-Core-static </td>
<td> 공전  </td>
<td> -</td>
</tr>
<tr>
<td>Brightcove-Player-FreeWheel </td>
<td> 공전 </td>
<td> iOS용 Brightcove-Player-Core,<br/>tvOS용 Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-FreeWheel-정적 </td>
<td> 공전 </td>
<td> iOS용 Brightcove-Player-Core-static,<br/>tvOS용 Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-GoogleCast </td>
<td> 공전 </td>
<td> Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-GoogleCast-정적 </td>
<td> 공전 </td>
<td> Brightcove-Player-Core-static</td>
</tr>
<tr>
<td>Brightcove-Player-IMA </td>
<td> 동적 </td>
<td> Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-IMA-정적 </td>
<td> 동적 </td>
<td> Brightcove-Player-Core-static</td>
</tr>
<tr>
<td>Brightcove-Player-Omniture </td>
<td> 공전 </td>
<td> Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-Omniture-정적 </td>
<td> 공전 </td>
<td> Brightcove-Player-Core-static</td>
</tr>
<tr>
<td>Brightcove-Player-Pulse </td>
<td> 동적 </td>
<td> Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-Pulse-정적 </td>
<td> 동적 </td>
<td> Brightcove-Player-Core-static</td>
</tr>
<tr>
<td>Brightcove-Player-SSAI </td>
<td> 동적 </td>
<td> Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-SSAI-정적 </td>
<td> 공전 </td>
<td> Brightcove-Player-Core-static</td>
</tr>
</tbody>
</table>


<h2>페어플레이<a name="FairPlay"></a></h2>

<p>FairPlay 보호 비디오 재생 지원이 코어에 통합되었습니다. <em>BrightcovePlayerSDK</em> 뼈대. 참조<a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/FairPlay.md">페어플레이 가이드</a> Brightcove Native Player SDK와 함께 FairPlay를 사용하는 방법에 대한 자세한 내용은</p>

<h2>사이드카 자막<a name="SidecarSubtitles"></a></h2>

<p>사이드카 자막 지원이 코어에 통합되었습니다. <em>BrightcovePlayerSDK</em> 뼈대. Brightcove Native Player SDK에서 사이드카 자막을 사용하는 방법에 대한 자세한 내용은<a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/SidecarSubtitles.md">사이드카 자막 가이드</a> .</p>

<h2>비디오 다운로드 및 오프라인 재생<a name="OfflinePlayback"></a></h2>

<p>릴리스 6.0.0부터 Brightcove Native Player SDK를 사용하면 온라인이든 오프라인이든 나중에 재생하기 위해 FairPlay 암호화로 보호된 비디오를 포함하여 HLS 비디오를 다운로드할 수 있습니다. 앱 개발자에게 문의&rsquo;자세한 내용은 s 가이드:</p>

<p><a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/OfflinePlayback.md">iOS 앱 개발자&rsquo; FairPlay를 통한 비디오 다운로드 및 오프라인 재생 가이드</a></p>

<h1>설치<a name="Installation"></a></h1>

<p>Brightcove Player SDK는 iOS용 정적 라이브러리 프레임워크 및 동적 프레임워크의 두 가지 설치 패키지를 제공합니다. 배포는 iOS 11 이상에서 지원됩니다.</p>

<p>Brightcove Player SDK는 tvOS 11.0 이상을 지원하는 동적 프레임워크를 제공합니다.</p>

<h2>코코아팟<a name="CocoaPods"></a></h2>

<p>당신이 사용할 수있는<a href="https://cocoapods.org">코코아팟</a>프로젝트에 Brightcove Player SDK를 추가합니다. 최신 정보를 찾을 수 있습니다<code> Brightcove-Player-Core</code>포드 스펙<a href="https://github.com/brightcove/BrightcoveSpecs/tree/master/Brightcove-Player-Core">여기</a> . podspec은 iOS와 tvOS를 모두 지원합니다. CocoaPods 1.0 이상이 필요하며 최신 버전을 권장합니다.</p>

<p>프로젝트에서 Brightcove CocoaPods를 사용할 때 다음을 추가하십시오. <code>원천 '</code> https://github.com/brightcove/BrightcoveSpecs.git' <code></code> Podfile의 시작 부분에.</p>

<p>기본 포드 지정<code> Brightcove-Player-Core</code>동적 라이브러리 프레임워크를 설치합니다. 정적 프레임워크를 설치하려면 다음을 추가하십시오. <code> -공전</code>이와 같이: <code>포드 'Brightcove-Player-Core-static'</code> .</p>

<p>동적 프레임워크 예:</p>

<pre><code>source 'https://github.com/CocoaPods/Specs' source 'https://github.com/brightcove/BrightcoveSpecs.git' platform :ios, '11.0' use_frameworks! target 'MyVideoPlayer' do pod 'Brightcove-Player-Core' end </code></pre>

<p>정적 프레임워크 예:</p>

<pre><code>source 'https://github.com/CocoaPods/Specs' source 'https://github.com/brightcove/BrightcoveSpecs.git' platform :ios, '11.0' use_frameworks! target 'MyVideoPlayer' do pod 'Brightcove-Player-Core-static' end </code></pre>

<p>설치를 업데이트할 때&rsquo; CococaPods 마스터 리포지토리를 업데이트하는 것처럼 최신 podspec을 로컬로 사용할 수 있도록 BrightcoveSpecs 리포지토리의 로컬 복사본을 새로 고치는 것이 좋습니다. 일반적으로 실행하면<code>포드 업데이트</code>터미널에서는 자동으로 발생하거나 다음을 사용하여 명시적으로 업데이트할 수 있습니다. <code>포드 리포지토리 업데이트</code> .</p>

<h2>수동 설치<a name="ManualInstallation"></a></h2>

<p>Brightcove Player SDK를 프로젝트에 수동으로 추가하려면:</p>

<ol>
<li>당사에서 최신 압축 릴리스를 다운로드하십시오. <a href="https://github.com/brightcove/brightcove-player-sdk-ios/releases">릴리스 페이지</a> .</li>
<li>추가하다<code> BrightcovePlayerSDK.framework</code>당신의 프로젝트에. 대상, iOS 또는 tvOS에 해당하는 버전을 사용해야 합니다.</li>
<li>에&ldquo;빌드 설정&rdquo;애플리케이션 대상의 탭에서&ldquo;프레임워크 검색 경로&rdquo;프레임워크에 대한 경로를 포함합니다. 프레임워크가 프로젝트와 다른 루트 디렉터리에 저장되지 않는 한 이 작업은 자동으로 수행되어야 합니다.</li>
<li><p>에&ldquo;일반적인&rdquo;응용 프로그램 대상의 탭에서 다음을 추가하십시오. &ldquo;프레임워크, 라이브러리, 임베디드 콘텐츠&rdquo;부분:</p>

<ul>
<li>BrightcovePlayerSDK.framework<code></code></li>
</ul>
</li>
<li>( <strong>동적 프레임워크</strong>만) 에&ldquo;일반적인&rdquo;응용 프로그램 대상의 탭에 추가&lsquo; BrightcovePlayerSDK.framework &rsquo; ~로&ldquo;임베디드 바이너리&rdquo;부분.</li>
<li>( <strong>동적 프레임워크</strong>만) 에&ldquo;빌드 단계&rdquo;탭, 추가&ldquo;스크립트 실행&rdquo;명령으로 단계<code>배시 $ {BUILT_PRODUCTS_DIR} /$ {FRAMEWORKS_FOLDER_PATH} /BrightcovePlayerSDK.framework/strip-frameworks.sh</code> . 확인하다&ldquo;설치 시에만 스크립트 실행&rdquo; . 이렇게 하면 앱 스토어 제출에 중요한 불필요한 아키텍처가 빌드에서 제거됩니다.</li>
<li>( <strong>정적 프레임워크</strong>만) 에&ldquo;빌드 설정&rdquo;응용 프로그램 대상의 탭에 추가<code> -오브제이C</code> ~로&ldquo;기타 링커 플래그&rdquo;빌드 설정.</li>
<li>( <strong>정적 프레임워크</strong>만) 파일 찾기<code> bcovpuiiconfont.ttf</code>내<code> BrightcovePlayerSDK.framework</code>글꼴 파일이 앱의 일부가 되도록 번들로 만들고 프로젝트 목록으로 직접 드래그합니다. 파일을 드래그한 후 앱에 추가해야 합니다. &rsquo;그렇게 하라는 메시지가 표시되면 대상을 빌드합니다. 앱이 빌드되면 글꼴 파일은 앱과 동일한 수준의 앱 번들에 있어야 합니다. &rsquo;■ Info.plist 파일. 글꼴 파일은 다음 중 일부를 제공합니다. <code> BrightcovePlayerUI</code>인터페이스 요소이지만 plist 자체에 나열될 필요는 없습니다.</li>
</ol>


<p>참고로 최신 릴리스를 찾고 다운로드하는 데 도움이 되는 모든 SDK 구성 요소와 해당 URL은 다음과 같습니다.</p>

<table>
<thead>
<tr>
<th>요소  </th>
<th> URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>Brightcove-Player-Core </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios/releases"></a></td>
</tr>
<tr>
<td>Brightcove-Player-FreeWheel </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios-fw/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios-fw/releases"></a></td>
</tr>
<tr>
<td>Brightcove-Player-IMA </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios-ima/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios-ima/releases"></a></td>
</tr>
<tr>
<td>Brightcove-Player-Omniture </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios-omniture/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios-omniture/releases"></a></td>
</tr>
<tr>
<td>Brightcove-Player-Pulse </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios-pulse/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios-pulse/releases"></a></td>
</tr>
<tr>
<td>Brightcove-Player-SSAI </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios-ssai/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios-ssai/releases"></a></td>
</tr>
</tbody>
</table>


<h2>수입품<a name="Imports"></a></h2>

<p>iOS용 Brightcove Player SDK는 다음과 같은 몇 가지 방법으로 코드로 가져올 수 있습니다.</p>

<pre><code>@import BrightcovePlayerSDK; </code></pre>

<pre><code>#import &lt;BrightcovePlayerSDK/BrightcovePlayerSDK.h&gt; </code></pre>

<pre><code>#import &lt;BrightcovePlayerSDK/[specific-class].h&gt; </code></pre>

<h1>빠른 시작<a name="QuickStart"></a></h1>

<p>iOS용 Brightcove Player SDK로 비디오 재생:</p>

<pre><code>// ** 자신의 계정 정보로 이 값을 사용자 정의합니다. ** static NSString * const kViewControllerPlaybackServicePolicyKey = @"..."; 정적 NSString * const kViewControllerAccountID = @"..."; 정적 NSString * const kViewControllerVideoID = @"..."; BCOVPlayerSDKManager *관리자 = [BCOVPlayerSDKManager 공유 관리자]; id&lt;BCOVPlaybackController&gt; 컨트롤러 = [매니저 createPlaybackController]; self.controller = 컨트롤러; // 이것을 강력한 속성에 저장 [self.view addSubview:controller.view]; BCOVPlaybackService *service = [[BCOVPlaybackService 할당] initWithAccountId:kAccountId policyKey:kPlaybackServicePolicyKey]; [서비스 findVideoWithVideoID:kViewControllerVideoID 매개변수:nil completion:^(BCOVVideo *video, NSDictionary *jsonResponse, NSError *error) { [controller setVideos:@[ video ]]; [controller play]; } ];</code></pre>

<p>메서드가 끝날 때 컨트롤러가 자동으로 해제되지 않도록 해야 합니다. 이를 수행하는 일반적인 방법은 컨트롤러에 대한 참조를 강력한 인스턴스 변수에 저장하는 것입니다.</p>

<h1>내장 PlayerUI 컨트롤<a name="PlayerUI"></a></h1>

<p>버전 5.1.0부터 Brightcove PlayerUI는 Core SDK 프레임워크에 완전히 통합되었습니다. PlayerUI는 즉시 사용 가능한 재생 및 광고를 위한 모든 기능을 갖춘 컨트롤 세트를 제공합니다.</p>

<p>PlayerUI는 설정이 빠르고 SSAI, Pulse 및 FreeWheel에 대한 광고 컨트롤을 표시하며 자신만의 레이아웃을 만들어 사용자 지정할 수 있습니다.</p>

<h2>PlayerUI 컨트롤 설정</h2>

<p>PlayerUI 컨트롤을 설정하려면 아래 지침을 따르십시오.</p>

<p>UIViewController에 속성을 생성하여<a href="Classes/BCOVPUIPlayerView.html"> BCOVPUIPlayerView</a> . NS <a href="Classes/BCOVPUIPlayerView.html"> BCOVPUIPlayerView</a>재생 컨트롤러를 모두 포함합니다. &rsquo; s 보기 및 제어 보기.</p>

<pre><code>// PlayerUI's Player View @property (nonatomic) BCOVPUIPlayerView *playerView; </code></pre>

<p>생성<a href="Classes/BCOVPUIBasicControlView.html"> BCOVPUIBasicControlView</a> , 그리고 나서<a href="Classes/BCOVPUIPlayerView.html"> BCOVPUIPlayerView</a> . 여기에서 재생 컨트롤러(및 재생 컨트롤러가 재생하는 모든 비디오)를 컨트롤과 연결합니다.</p>

<pre><code>// 컨트롤 뷰를 만들고 구성합니다. BCOVPUIBasicControlView *controlView = [BCOVPUIBasicControlView basicControlViewWithVODLayout]; self.playerView = [[BCOVPUIPlayerView 할당] initWithPlaybackController:self.playbackController 옵션:nil controlsView:controlView]; // 비디오 보기에 BCOVPUIPlayerView를 추가합니다. [self.videoView addSubview:self.playerView];</code></pre>

<p>너&rsquo;플레이어 보기에 대한 레이아웃을 설정해야 하는 경우 자동 레이아웃 또는 이전 Springs &amp; Struts 접근 방식을 사용하여 이를 수행할 수 있습니다.</p>

<p><strong>스프링 및 스트럿:</strong></p>

<p>레이아웃의 비디오 컨테이너와 일치하도록 플레이어 보기를 설정합니다( <code>동영상보기</code> ) 크기가 조정될 때.</p>

<pre><code>self.playerView.frame = self.videoView.bounds; self.playerView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;</code></pre>

<p><strong>자동 레이아웃</strong></p>

<p>설정<code>변환 AutoresizingMaskIntoConstraints</code> ~에<a href="Classes/BCOVPUIPlayerView.html"> BCOVPUIPlayerView</a>에게<code>아니요</code> .</p>

<pre><code>self.playerView.translatesAutoresizingMaskIntoConstraints = NO;</code></pre>

<p>그런 다음 레이아웃에 대한 제약 조건을 추가합니다. 당신의 상단, 오른쪽, 왼쪽 및 하단 앵커를 설정<a href="Classes/BCOVPUIPlayerView.html"> BCOVPUIPlayerView</a>그것과 동등하게<code>동영상보기</code></p>

<pre><code>[NSLayoutConstraint activateConstraints:@[ [self.playerView.topAnchor constraintEqualToAnchor:self.videoView.topAnchor], [self.playerView.rightAnchor constraintEqualToAnchor:self.videoView.rightAnchor], [self.playerView.leftAnchor constraintEqualToAnchor:self.videoView.leftAnchor], [self.playerView.bottomAnchor constraintEqualToAnchor:self.videoView.bottomAnchor], ]]; </code></pre>

<p><strong>알림:</strong> PlayerUI는 다양한 그래픽에 작은 글꼴 파일을 사용합니다. 정적 프레임워크를 설치하고 CocoaPods를 사용하지 않는 경우 파일을 추가해야 합니다. <code> bcovpuiiconfont.ttf</code> ~로부터<code> BrightcovePlayerSDK.framework</code>글꼴 파일이 앱 번들에 복사되도록 프로젝트 목록에 직접 번들</p>

<h2>BCOVPUIPlayerViewOptions<a href="Classes/BCOVPUIPlayerViewOptions.html"></a></h2>

<p>NS <a href="Classes/BCOVPUIPlayerViewOptions.html"><code> BCOVPUIPlayerViewOptions</code></a>클래스를 사용하면 초기화 시 일부 BCOVPlayerUI 동작을 사용자 지정할 수 있습니다. 다음을 사용자 정의할 수 있습니다.</p>

<ul>
<li><code>점프백 간격</code>뒤로 점프 버튼을 눌렀을 때 플레이어가 뒤로 탐색하는 시간(초)입니다.</li>
<li><code>hideControls간격</code>마지막 터치 이벤트 후 컨트롤이 숨겨지기 전의 시간(초)입니다.</li>
<li><code>hideControlsAnimationDuration</code>컨트롤이 숨김 상태로 전환되는 데 걸리는 시간(초)입니다.</li>
<li><code>showControlsAnimationDuration</code>컨트롤이 표시될 때까지 걸리는 시간(초)입니다.</li>
<li><code>자세히 알아보기버튼브라우저 스타일</code>탭할지 여부를 결정하는 설정&ldquo;더 알아보기&rdquo;버튼을 클릭하면 외부 브라우저(기본 설정) 또는 내부 브라우저에 클릭연결 링크가 표시됩니다.</li>
<li><code>프레젠테이션 보기 컨트롤러</code>다른 뷰 컨트롤러(예: 폐쇄 캡션 선택 뷰 컨트롤러)를 표시하는 데 사용할 UIViewController 하위 클래스입니다.</li>
<li><code>자동 제어 유형 선택</code>원하든 원하지 않든<code> BCOVPUIPlayerView</code>고르다<code> BCOVPUIBasicControlView</code>비디오 유형에 따라 자동으로 입력합니다. 영상이 VOD라면<code> BasicControlViewWithVODLayout</code>라이브를 위해 사용될 것입니다<code>기본컨트롤뷰와 라이브레이아웃</code>라이브 DVR의 경우<code>기본ControlViewWithLiveDVRLayout</code> . 이 값이 다음으로 설정되면<code>예</code> NS <code> BCOVPUIBasicControlView</code>상속받은 재산<code> BCOVPUIPlayerView</code>초기화는 무시됩니다.</li>
</ul>


<p>옵션은 다음 방법을 사용하여 설정할 수 있습니다.</p>

<pre><code> BCOVPlayerSDKManager *manager = [BCOVPlayerSDKManager sharedManager]; id&lt;BCOVPlaybackController&gt; controller = [manager createPlaybackController]; BCOVPUIPlayerViewOptions *options = [[BCOVPUIPlayerViewOptions alloc] init]; options.jumpBackInterval = 5; BCOVPUIPlayerView *playerView = [[BCOVPUIPlayerView alloc] initWithPlaybackController:playbackController options:options]; </code></pre>

<h2>제공되는 레이아웃</h2>

<p>다양한 유형의 비디오를 지원하기 위해 세 가지 레이아웃이 제공됩니다.</p>

<ul>
<li><p><code></code> BCOVPUIControlLayout <code>기본VOD컨트롤 레이아웃</code>일반 주문형 비디오 스트림의 기본 레이아웃입니다.</p></li>
<li><p><code></code> BCOVPUIControlLayout <code>기본 라이브 컨트롤 레이아웃</code>라이브 비디오를 위한 레이아웃입니다.</p></li>
<li><p><code></code> BCOVPUIControlLayout <code>기본 라이브DVR컨트롤 레이아웃</code> DVR 컨트롤이 있는 라이브 비디오 스트림의 레이아웃입니다.</p></li>
</ul>


<p>일반적으로 새 레이아웃을 즉시 설정합니다. <a href="Classes/BCOVPUIPlayerView.html"><code> BCOVPUIPlayerView</code></a>생성되지만 언제든지 새 레이아웃을 설정할 수도 있습니다. 예를 들어 다음과 같이 새 VOD 레이아웃을 설정할 수 있습니다.</p>

<pre><code>playerView.controlsView.layout = [BCOVPUIControlLayout 기본VODControlLayout]</code></pre>

<h2>사용자 정의 레이아웃</h2>

<p>기본 레이아웃 외에도 새로운<a href="Classes/BCOVPUIControlLayout.html"><code> BCOVPUIControlLayout</code></a>나만의 디자인으로.</p>

<ol>
<li><p>먼저 다음을 사용하여 레이아웃에 들어갈 컨트롤을 만듭니다. <a href="Classes/BCOVPUIBasicControlView.html"><code> BCOVPUIBasicControlView</code></a> layoutViewWithControlFromTag:너비:탄력: <code> . 각 컨트롤은</code><a href="Classes/BCOVPUILayoutView.html"><code> BCOVPUILayoutView</code></a>제어 간격을 결정합니다.</p></li>
<li><p>당신은 설정할 수 있습니다<code>너비</code>각 레이아웃 보기의 기본 너비(컨트롤 유형 기반)로 변경하거나 사용자 고유의 너비를 지정할 수 있습니다.</p></li>
<li><p>사용<code>탄력</code>컨트롤을 포함하는 레이아웃 보기가 컨트롤 막대를 채우기 위해 너비를 조정하는 정도를 결정하는 인수입니다.</p>

<ul>
<li>탄력성이 0이면 레이아웃 보기의 크기가 고정됩니다.</li>
<li>탄력성 값이 0보다 크면 해당 컨트롤 막대의 다른 모든 탄력적 보기에 비해 사용 가능한 공간을 채우기 위해 레이아웃 보기가 얼마나 커질지 결정합니다. 탄력성 값이 2.0인 레이아웃 보기는 탄력성 값이 1.0인 레이아웃 보기보다 두 배 빠르게 성장합니다. 일반적으로 레이아웃 보기 행에는 탄력성이 0보다 큰 컨트롤이 하나 이상 있습니다.</li>
</ul>
</li>
</ol>


<p>다음은 다양한 기본 컨트롤을 만드는 예입니다.</p>

<pre><code>// Create various standard layout views // Standard play/pause button BCOVPUILayoutView *playbackLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagButtonPlayback width:kBCOVPUILayoutUseDefaultValue elasticity:0.0]; // Standard jump back button BCOVPUILayoutView *jumpBackButtonLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagButtonJumpBack width:kBCOVPUILayoutUseDefaultValue elasticity:0.0]; // Current time indicator BCOVPUILayoutView *currentTimeLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagLabelCurrentTime width:kBCOVPUILayoutUseDefaultValue elasticity:0.0]; // Time separator - typically the '/' character BCOVPUILayoutView *timeSeparatorLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagLabelTimeSeparator width:kBCOVPUILayoutUseDefaultValue elasticity:0.0]; // Video duration label BCOVPUILayoutView *durationLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagLabelDuration width:kBCOVPUILayoutUseDefaultValue elasticity:0.0]; // Slider bar used for scrubbing through the video // The elasticity is set to 1 so that it can resize to fill available space BCOVPUILayoutView *progressLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagSliderProgress width:kBCOVPUILayoutUseDefaultValue elasticity:1.0]; // Closed caption button // This button is initially hidden ('removed'), and will be shown // if closed captions or audio tracks are available. BCOVPUILayoutView *closedCaptionLayoutView = [BCOVPUIBasicControlView 레이아웃ViewWithControlFromTag:BCOVPUIViewTagButtonClosedCaption 너비:kBCOVPUILayoutUseDefaultValue 탄력성:0.0]; closedCaptionLayoutView.removed = 예; // 전체 화면 버튼 BCOVPUILayoutView *screenModeLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagButtonScreenMode 너비:kBCOVPUILayoutUseDefaultValue 탄력성:0.0]; // AirPlay 버튼 // 이 버튼은 처음에는 숨겨져 있으며('제거'), // AirPlay 장치를 사용할 수 있는 경우 표시됩니다. BCOVPUILayoutView *externalRouteLayoutView = [BCOVPUIBasicControlView 레이아웃ViewWithControlFromTag:BCOVPUIViewTagViewExternalRoute 너비:kBCOVPUILayoutUseDefaultValue 탄력성:0.0]; externalRouteLayoutView.removed = 예; // 빈 보기 - 스페이서로 사용됨 BCOVPUILayoutView *spacerLayoutView1 = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagViewEmpty 너비:1.0 탄성:1.0]; // 빈 보기 - 스페이서로 사용 BCOVPUILayoutView *spacerLayoutView2 = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagViewEmpty 너비:1.0 탄성:1.0]; // 빈 보기 - 사용자 정의 UIImageView가 하위 보기로 추가됨 BCOVPUILayoutView *logoLayoutView1 = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagViewEmpty width:80.0 elastic:1.0]; // 빈 보기 - 사용자 정의 UIImageView를 하위 보기로 추가합니다. BCOVPUILayoutView *logoLayoutView2 = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagViewEmpty width:36.0 elastic:0.0];</code></pre>

<p>자신의 보기(로고, 컨트롤, 아무것도 없음 등)를 배치할 수 있는 빈 레이아웃 보기를 만들 수도 있습니다. 이 코드는 배치하는 방법을 보여줍니다<code> UI이미지</code>위에서 만든 logoLayoutView1 내부의 로고.</p>

<pre><code>// 컨트롤 막대에 표시할 이미지 보기 내부에 로고 이미지를 만듭니다. UIImage *logoImage1 = [UIImage imageNamed:@"myLogo"]; UIImageView *logoImageView1 = [[UIImageView 할당] initWithImage:logoImage1]; logoImageView1.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; logoImageView1.contentMode = UIViewContentModeScaleAspectFit; logoImageView1.frame = logoLayoutView1.frame; // 빈 레이아웃 뷰에 이미지 뷰를 추가합니다. [logoLayoutView1 addSubview:logoImageView1];</code></pre>

<p>이제 레이아웃 보기에 패키지된 다양한 컨트롤이 있으므로 배열로 정렬되며, 각 컨트롤은 컨트롤 막대, 즉 한 줄의 컨트롤을 나타냅니다. 세로 및 가로 방향에 대해 다른 레이아웃을 가질 수 있으므로 일반적으로 두 개의 서로 다른 컨트롤 막대 배열을 설정합니다.</p>

<p>가로 방향의 표준 레이아웃에서 컨트롤은 단일 배열에 배열되고 해당 배열은 전체 컨트롤 집합을 나타내는 다른 배열에 저장됩니다.</p>

<pre><code> NSArray *standardLayoutLine1 = @[ playbackLayoutView, jumpBackButtonLayoutView, currentTimeLayoutView, timeSeparatorLayoutView, durationLayoutView, progressLayoutView, spacerLayoutView1, logoLayoutView1, spacerLayoutView2, closedCaptionLayoutView, screenModeLayoutView, externalRouteLayoutView ]; NSArray *standardLayoutLines = @[ standardLayoutLine1 ]; </code></pre>

<p>세로 방향의 컴팩트 레이아웃에서는 각 줄에 하나씩 두 개의 컨트롤 배열이 생성됩니다. 이러한 어레이는 컴팩트 레이아웃을 나타내는 다른 어레이로 패키징됩니다.</p>

<p>각 레이아웃의 대부분의 컨트롤에는 정확히 동일한 개체가 사용됩니다. 이 작업이 완료되고 세로 방향과 가로 방향 사이를 전환하면 개체가 부드러운 애니메이션을 사용하여 새 위치로 이동합니다.</p>

<pre><code> NSArray *compactLayoutLine1 = @[ currentTimeLayoutView, progressLayoutView, durationLayoutView ]; NSArray *compactLayoutLine2 = @[ playbackLayoutView, jumpBackButtonLayoutView, spacerLayoutView1, closedCaptionLayoutView, screenModeLayoutView, externalRouteLayoutView, logoLayoutView2 ]; NSArray *compactLayoutLines = @[ compactLayoutLine1, compactLayoutLine2 ]; </code></pre>

<p>마지막으로, 이제 두 가지 레이아웃 구성(전체 너비 및 컴팩트 너비)이 있으므로 새 레이아웃을 만들 수 있습니다. <a href="Classes/BCOVPUIControlLayout.html"><code> BCOVPUIControlLayout</code></a>개체 및 플레이어에서 설정&rsquo; s 컨트롤 뷰.</p>

<pre><code> BCOVPUIControlLayout *customLayout = [[BCOVPUIControlLayout alloc] initWithStandardControls:standardLayoutLines compactControls:compactLayoutLines]; playerView.controlsView.layout = customLayout; </code></pre>

<p>자주 표시하거나 숨겨야 하는 컨트롤이 있는 경우 다음을 설정할 수 있습니다. <code>제거됨</code>해당 컨트롤의 속성&rsquo; s 레이아웃 보기. 컨트롤을 변경한 경우 다음으로 전화하십시오. <code> setNeedsLayout</code>플레이어뷰에서&rsquo; s controlView:</p>

<pre><code> logoLayoutView1.removed = YES; [playerView.controlsView setNeedsLayout]; </code></pre>

<p>또한 몇 가지 일반<a href="Classes/BCOVPUIControlLayout.html"><code> BCOVPUIControlLayout</code></a>속성:</p>

<ul>
<li><code>컨트롤바 높이</code>각 컨트롤 행의 크기를 설정합니다.</li>
<li><code>수평 항목 간격</code>각 사이의 간격을 설정합니다. <a href="Classes/BCOVPUILayoutView.html"><code> BCOVPUILayoutView</code></a>각 컨트롤 바에서</li>
<li><code>컴팩트 레이아웃최대폭</code>사용되는 컨트롤 집합을 결정합니다. 컨트롤 뷰가 다음보다 작은 경우<code>컴팩트 레이아웃최대폭</code> , 컴팩트 컨트롤 세트가 사용되며, 그렇지 않으면 표준 컨트롤이 사용됩니다.</li>
</ul>


<p>표시되는 컨트롤 집합을 변경하려면 새 컨트롤을 만들고 설치해야 합니다. <a href="Classes/BCOVPUIControlLayout.html"><code> BCOVPUIControlLayout</code></a> . 새로운 컨트롤은 언제든지 설치할 수 있습니다.</p>

<h2>더 많은 사용자 정의 예</h2>

<p>PlayerUI 사용자 정의의 더 많은 예는 BrightcoveOS GitHub 리포지토리의 PlayerUI 폴더에서 샘플 코드를 볼 수 있습니다.</p>

<p><a href="https://github.com/BrightcoveOS/ios-player-samples">[https://github.com/BrightcoveOS/ios-player-samples](https://github.com/BrightcoveOS/ios-player-samples)</a></p>

<h1>tvOS용 내장 TV 플레이어 컨트롤<a name="TVPlayer"></a></h1>

<p>Brightcove Native Player SDK에는 Apple TV의 tvOS에서 재생할 수 있는 컨트롤이 내장되어 있습니다. Brightcove Native Player SDK와 함께 내장 TV 플레이어 UI를 사용하는 방법에 대한 자세한 내용은 다음을 참조하십시오. <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/TVPlayer.md"> TV 플레이어 가이드</a> .</p>

<h1>에어플레이<a name="AirPlay"></a></h1>

<p>설정하여 AirPlay 기능을 활성화하십시오. <code> setAllowsExternalPlayback</code>당신의 재산<a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a>에게<code>진실</code> . AirPlay 장치가 네트워크에서 발견되면 AirPlay 버튼이 재생 컨트롤에 표시됩니다.</p>

<p>현재 IMA는 AirPlay를 지원하는 유일한 광고 플러그인이며 프리롤 및/또는 포스트롤 광고를 사용할 때만 가능합니다. Pulse, SSAI 또는 FreeWheel 광고 플러그인과 함께 AirPlay를 사용하면 예기치 않은 동작이 발생할 수 있습니다.</p>

<p>또한 AirPlay 2를 지원하고 오디오 출력을 위해 여러 장치를 선택할 수 있도록 하려면 몇 가지 추가 작업을 수행해야 합니다. 너 먼저&rsquo;설정할 수 있도록 AVAudioSession을 구성해야 합니다. <code> routeSharingPolicy</code> . 예를 들면 다음과 같습니다.</p>

<pre><code>[AVAudioSession.sharedInstance setCategory:AVAudioSessionCategoryPlayback mode:AVAudioSessionModeMoviePlayback routeSharingPolicy:AVAudioSessionRouteSharingPolicyLongForm options:0 error:nil]; </code></pre>

<p>또한 다음을 통해 하나 이상의 재생 명령을 구성해야 합니다. <code> MPRemoteCommandCenter</code> . 최소한 당신은&rsquo;둘 다 구성하고 싶습니다<code>일시 중지 명령</code>그리고<code>플레이커맨드</code> . 예를 들어:</p>

<pre><code>MPRemoteCommandCenter *center = MPRemoteCommandCenter.sharedCommandCenter; [center.pauseCommand addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull 이벤트) { [self.playbackController pause]; return MPRemoteCommandHandlerStatusSuccess; } ]; [center.playCommand addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull 이벤트) { [self.playbackController play]; return MPRemoteCommandHandlerStatusSuccess; } ];</code></pre>

<p>iOS 11 이상을 실행하는 기기는 다음을 활용합니다. <code> AVRoutePickerView</code>두 개의 대리자 메서드가 있습니다. 이러한 대리자 메서드는<a href="Protocols/BCOVPUIPlayerViewDelegate.html"><code> BCOVPUIPlayerViewDelegate</code></a> . 방법은 다음과 같습니다.</p>

<pre><code>- (void)routePickerViewWillBeginPresentingRoutes:(AVRoutePickerView *)routePickerView; - (void)routePickerViewDidEndPresentingRoutes:(AVRoutePickerView *)routePickerView; </code></pre>

<p>NS <code> AVRouteDetector</code> AirPlay 경로를 검색하는 데 사용되는<a href="Classes/BCOVPUIBasicControlView.html"><code> BCOVPUIBasicControlView</code></a>개체를 활성화하거나 비활성화할 수 있도록<code>경로 감지 활성화</code>필요에 따라 재산.</p>

<p>사과당&rsquo;문서: &ldquo;<em>경로 감지는 전력 소비를 크게 증가시키며 다음과 같은 경우 꺼야 합니다. &rsquo;더 이상 필요하지 않습니다.</em>&rdquo;</p>

<pre><code>// Objective-C self.playerView.controlsView.routeDetector.routeDetectionEnabled = NO; // Swift playerView?.controlsView.routeDetector.isRouteDetectionEnabled = false </code></pre>

<p>AirPlay 2를 앱에 통합하는 방법에 대한 자세한 내용은<a href="https://developer.apple.com/documentation/avfoundation/media_playback_and_selection/getting_airplay_2_into_your_app?language=objc">앱에 Airplay 2 가져오기</a>선적 서류 비치.</p>

<p><strong>중요 사항: AirPlay 2는 iOS 11.4 이상을 실행하는 기기에서만 지원됩니다.</strong></p>

<h1>비디오 360 <a name="Video360"></a></h1>

<p>Native Player SDK에는 360도 구형 비디오를 대화식으로 표시하기 위한 지원이 포함되어 있습니다. 360도 동영상에는 다음 태그가 지정되어야 합니다. &ldquo;투사&rdquo;값을 포함하는 필드 속성&ldquo;정방형&rdquo; . 이러한 비디오는 다른 비디오와 동일한 방식으로 로드 및 재생되지만 AVPlayerLayer 대신 OpenGL ES 레이어에 표시됩니다.</p>

<p>메모: &ldquo;정방형&rdquo;현재 360 소스 비디오에 지원되는 유일한 프로젝션 형식입니다.</p>

<p>또한 PlayerUI에는 기본 패닝 제스처, 보기에 대한 자이로스코프 동작 감지 및 Video 360 자산이 재생될 때 표시되는 새로운 Video 360 버튼을 제공하는 Video 360에 대한 지원이 내장되어 있습니다. 이 버튼은 iPhone에만 표시되며 일반 보기와&ldquo; VR 고글&rdquo;화면이 두 개로 분할되고 각 눈에 대해 동일한 장면이 렌더링되어 장치를 머리 장착 구성에서 사용할 수 있는 보기입니다. iPad에는 단일 작동 모드(패닝 제스처 지원을 통한 모션 감지)만 있기 때문에 Video 360 버튼이 필요하지 않습니다.</p>

<p>Video 360을 지원하는 것은 비디오를 재생하는 것만큼 간단합니다. 때&ldquo;투사&rdquo; field 속성이 감지되면 Native Player SDK가 OpenGL ES에서 비디오 설정 및 표시를 자동으로 처리하고 적절한 경우 Video 360 버튼을 설치합니다.</p>

<p>Video Cloud 외부에서 360도 비디오를 재생하는 경우&ldquo;투사&rdquo;재산<a href="Classes/BCOVVideo.html"><code> BCOV비디오</code></a>값을 가진 객체&ldquo;정방형&rdquo; .</p>

<p>VR 고글 모드로 최상의 사용자 경험을 제공하려면 다음을 사용해야 합니다. <a href="Protocols/BCOVPUIPlayerViewDelegate.html"><code> BCOVPUIPlayerViewDelegate</code></a>이 모드가 활성화되면 감지하는 방법입니다. 이렇게 하면 장치를 가로 방향으로 강제 설정할 수 있습니다(이 방향이 VR 고글 보기에 적합한 유일한 방향이기 때문).</p>

<p>다음 코드는 일반 360도 보기와 VR 고글 모드 간에 전환할 때 강제 방향 변경을 처리하는 방법을 보여줍니다.</p>

<pre><code> // Set this to YES when displaying a VR goggles video @property (nonatomic) BOOL landscapeOnly; // UIViewController override: // Lets us control the orientation of the device - (UIInterfaceOrientationMask)supportedInterfaceOrientations { if (self.landscapeOnly) { return UIInterfaceOrientationMaskLandscape; } return UIInterfaceOrientationMaskAll; } // BCOVPUIPlayerViewDelegate method - (void)didSetVideo360NavigationMethod:(BCOVPUIVideo360NavigationMethod)navigationMethod projectionStyle:(BCOVVideo360ProjectionStyle)projectionStyle { switch (projectionStyle) { case BCOVVideo360ProjectionStyleNormal: NSLog(@"BCOVVideo360ProjectionStyleNormal"); self.landscapeOnly = NO; break; case BCOVVideo360ProjectionStyleVRGoggles: NSLog(@"BCOVPUIVideo360NavigationDeviceMotionTracking"); self.landscapeOnly = YES; { UIDeviceOrientation currentDeviceOrientation = [UIDevice currentDevice].orientation; switch (currentDeviceOrientation) { case UIDeviceOrientationLandscapeLeft: case UIDeviceOrientationLandscapeRight: // all good break; default: { // switch orientation NSNumber *value = [NSNumber numberWithInt:UIInterfaceOrientationLandscapeLeft]; [[UIDevice currentDevice] setValue:value forKey:@"orientation"]; break; } } } break; } [UIViewController attemptRotationToDeviceOrientation]; } </code></pre>

<p>PlayerUI는 360도 비디오 탐색을 처리하기 위해 제스처를 설치하지만 자체 컨트롤을 사용하는 경우 가상 카메라의 보기 매개변수를 직접 설정할 수 있습니다. NS <a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a>규약&rsquo; NS <code>뷰프로젝션</code>속성을 사용하여 이러한 매개변수를 설정할 수 있습니다. 속성은<a href="Classes/BCOVVideo360ViewProjection.html"><code> BCOVVideo360View프로젝션</code></a>다음과 같은 기본 가상 카메라 설정이 포함된 클래스<code>팬</code> , <code>경사</code> , 그리고<code>줌</code> . 설정을 변경하려면 현재 인스턴스의 복사본을 만들고 새 인스턴스의 설정을 변경한 다음 다시 할당합니다. <code>뷰프로젝션</code>재산.</p>

<h2>아키텍처 개요<a name="ArchitecturalOverview"></a></h2>

<p><img src="architecture01.png" alt="Architectural Overview 1" /></p>

<p>iOS용 Brightcove Player SDK의 진입점은<a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlayerSDKManager.h"> [ <code> BCOVPlayerSDKManager</code> ](클래스/BCOVPlayerSDKManager.html)</a>싱글톤 객체. 이 관리자는 플러그인 구성 요소의 등록 및 기타 하우스키핑 작업을 처리하지만 주로 개체 팩토리 역할을 합니다. 내 앱&rsquo; s 뷰 컨트롤러는 Manager에 대한 참조를 얻고 이를 사용하여<a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h"> [ <code> BCOV재생 컨트롤러</code> ](프로토콜/BCOVPlaybackController.html)</a> . 재생 컨트롤러&rsquo; NS <code>보다</code>속성은 궁극적으로 화면에 비디오 콘텐츠를 표시하는 AVPlayerLayer 개체를 포함하는 UIView를 노출합니다. 재생 컨트롤러도 허용<a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L667-L793"> [ <code> BCOVPlaybackControllerDelegate</code> ](프로토콜/BCOVPlaybackControllerDelegate.html)</a> , 다양한 비디오 재생 이벤트에 응답하기 위해 구현할 수 있습니다.</p>

<p>재생 컨트롤러는 현재 비디오의 재생에 영향을 주는 메서드와 속성을 제공합니다. 그러나 내부적으로 재생 컨트롤러는<a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackSession.h"> [ <code> BCOV재생 세션</code> ](프로토콜/BCOVPlaybackSession.html)</a>물체. 재생 세션은 비디오 콘텐츠를 준비하고 재생하는 실제 작업을 수행하며 비디오를 포함합니다. &rsquo;메타데이터 및<code> AVPlayer</code> . 재생 컨트롤러에는 비디오가 끝날 때 자동으로 또는 메서드 호출을 통해 수동으로 현재 재생 세션에서 다음 재생 세션으로 진행하는 메커니즘이 있습니다. 재생 컨트롤러가 새 세션으로 진행되면 이전 세션이 삭제되고 다시 사용할 수 없습니다.</p>

<p>재생 컨트롤러에는 두 가지 다른 요소가 있습니다. <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackSessionProvider.h"> [ <code> BCOVPlaybackSessionProvider</code> ](프로토콜/BCOVPlaybackSessionProvider.html)</a> , 및 목록<a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L538-L655"> [ <code> BCOVPlaybackSessionConsumer</code> ](프로토콜/BCOVPlaybackSessionConsumer.html)</a> NS. 이름에서 알 수 있듯이 재생 세션 공급자는 재생 세션을 만들고 재생 컨트롤러에 전달합니다. 그런 다음 재생 컨트롤러는 목록에 있는 각 재생 세션 소비자에게 세션을 전달합니다. 세션 공급자와 세션 소비자 API는 모두 플러그인 개발자가 사용하도록 설계되었으며 이 문서에서 자세히 설명하지 않습니다.</p>

<p>위에서 설명한 클래스에서 제공하는 재생 기능 외에도 소수의 값 클래스가 있습니다. iOS용 Player SDK에 특정한 데이터를 보관하는 데 사용됩니다. 이들 각각은 아래의 해당 섹션에 더 자세히 설명되어 있습니다.</p>

<h2>재생, 일시 중지 및 탐색<a name="PlayPauseSeek"></a></h2>

<p>iOS용 Brightcove Player SDK는<a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a> . <strong>동등한 AVPlayer를 사용하는 대신 이러한 방법을 사용하는 것이 중요합니다.</strong> 기본 구현에서 이러한 객체는 호출을 AVPlayer의 해당 메서드로 직접 전달합니다. 그러나 플러그인을 사용하는 경우 기능을 추가하기 위해 기본 동작을 재정의할 수 있습니다. 예를 들어 광고 플러그인을 사용하는 경우<a href="Protocols/BCOVPlaybackController.html#//api/name/play"><code> [BCOVPlaybackController 재생]</code></a>처음으로 콘텐츠를 시작하기 전에 프리롤이 재생될 수 있습니다. 플러그인이 기본 동작을 재정의하는 방법에 대해 자세히 알아보려면 각 플러그인 README.md를 참조하거나 에서 카테고리 확장을 확인하십시오. <a href="Classes/BCOVSessionProviderExtension.html"><code> BCOVSessionProvider 확장</code></a>플러그인이 추가할 수 있습니다.</p>

<p><em>AVPlayer에서 직접 재생, 일시 중지 또는 탐색을 호출하면 정의되지 않은 동작이 발생할 수 있습니다.</em></p>

<h2>동영상 미리 로드<a name="PreloadingVideos"></a></h2>

<p>원하는 경우 재생 목록에 예정된 비디오를 미리 로드하도록 선택할 수 있습니다. 한 가지 가능한 접근 방식은 두 개의 재생 컨트롤러를 사용하여 비디오 목록을 이중 버퍼링하는 것입니다. 예를 들면 다음과 같습니다.</p>

<ol>
<li>두 개의 재생 컨트롤러 초기화</li>
<li>플레이어 보기를 설정하고 두 개의 재생 컨트롤러 중 하나를 playerView에 할당합니다. &rsquo; s playbackController 속성(이제 활성 재생 컨트롤러)</li>
<li>재생목록이 준비되면 재생목록(또는 동영상 배열 속성만)을 속성에 할당합니다. &rsquo;각 비디오에 개별적으로 액세스해야 합니다.</li>
<li>비디오 배열에서 첫 번째 비디오를 가져와 활성 재생 컨트롤러에 제공합니다( <code> [self.playbackController1 setVideos:@[self.videos.firstObject]]</code> )</li>
<li>활용<code>플레이백컨트롤러:didProgressTo:</code>재생 컨트롤러의 delegate 메소드는 현재 비디오가 다음 비디오를 미리 로드하기 시작할 위치까지 충분히 진행되었는지 확인합니다.</li>
<li>일단 결정하면&rsquo;미리 로드하는 시간은 비디오 배열에서 다음 비디오를 가져와서 대체 재생 컨트롤러에 설정합니다.</li>
<li>현재 비디오가 완료되면 playerView의 playbackController를 대체 재생 컨트롤러로 설정하십시오</li>
<li>헹구고 5-7단계를 반복합니다.</li>
</ol>


<p>실제 예제를 보려면 다음을 다운로드할 수 있습니다. <a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Player/VideoPreloading">동영상 미리 로드</a>우리의 샘플 앱<a href="https://github.com/BrightcoveOS/ios-player-samples">플레이어 샘플</a>저장소.</p>

<p><strong>참고: 클라이언트에서 사용 가능한 메모리 양을 고려할 수 있습니다. &rsquo; s 장치 및 연결 속도. Wi-Fi에 연결되어 있지 않은 경우 동영상을 미리 로드하면 현재 동영상에 영향을 줄 수 있습니다. &rsquo; s 네트워크 리소스.</strong></p>

<h2>소스 선택(HLS, MP4, HTTP/HTTPS) <a name="SourceSelection"></a></h2>

<p>iOS용 Brightcove Player SDK는 클라이언트에 여러 URL 및 전달 유형을 첨부할 수 있는 기능을 제공합니다( <a href="Classes/BCOVSource.html"><code> BCOV 소스</code></a> ) 단일 비디오( <a href="Classes/BCOVVideo.html"><code> BCOV비디오</code></a> ). 예를 들어 재생 서비스에서 비디오를 검색하는 경우 HTTP 및 HTTPS 버전과 함께 단일 비디오에 대해 HLS 또는 MP4 변환이 혼합되어 있을 수 있습니다. 선택되는 소스 중 하나는 소스 선택 정책 블록에 의해 결정됩니다. 기본 소스 선택 정책은 첫 번째 HLS를 선택합니다. <a href="Classes/BCOVSource.html"><code> BCOV 소스</code></a>각각에<a href="Classes/BCOVVideo.html"><code> BCOV비디오</code></a> , HTTP보다 HTTPS 소스가 선호됩니다.</p>

<p>소스 선택은 다음을 생성하여 재정의할 수 있습니다. <a href="Classes/BCOVBasicSessionProviderOptions.html"><code> BCOVBasicSessionProvider 옵션</code></a>그리고 그것을 사용하여<a href="Classes/BCOVBasicSessionProvider.html"><code> BCOVBasicSessionProvider</code></a> . 예를 들면 다음과 같습니다.</p>

<pre><code>BCOVPlayerSDKManager *sdkManager = [BCOVPlayerSDKManager 공유 관리자]; BCOVBasicSessionProviderOptions *옵션 = [[BCOVBasicSessionProviderOptions 할당] 초기화]; options.sourceSelectionPolicy = &lt;정책&gt; id&lt;BCOVPlaybackSessionProvider&gt; 제공자 = [sdkManager createBasicSessionProviderWithOptions:options]; idBCOVPlaybackController playbackController = [sdkManager createPlaybackControllerWithSessionProvider:제공자 viewStrategy:nil];</code></pre>

<p>이 기본 선택 정책이 작동하지 않는 경우 소스를 선택하는 몇 가지 대안이 있습니다.</p>

<ul>
<li><p>재생 서비스를 통해 Video Cloud에서 비디오를 검색하는 경우 전화하기 전에<code> [BCOVPlaybackController setVideos:]</code> , 업데이트 방법을 사용하십시오. <code> BCOV비디오</code>원하는 소스만 포함하려면(참조&ldquo;가치&rdquo;자세한 내용은 섹션).</p></li>
<li><p>도우미 메서드를 사용할 수 있습니다. <code> [BCOVBasicSourceSelectionPolicy sourceSelectionHLSWithScheme:scheme]</code>특정 체계를 선호하는 정책을 생성합니다. 이것은 HTTPS를 선호하는 기본 소스 선택 정책을 만드는 데 사용되는 방법입니다.</p></li>
<li><p>비디오 개체를 업데이트하는 것과 유사하게 고유한 소스 선택 블록을 구현할 수도 있습니다.</p>

<pre><code> options.sourceSelectionPolicy = ^ BCOVSource *(BCOVVideo *video) { &lt;Check video.sources for source&gt; &lt;Return source&gt; }; </code></pre></li>
</ul>


<p>MP4 비디오 사용과 관련하여 App Store 제한 사항이 있음을 유의하십시오. 자세한 내용은 최신 Apple 개발자 정보를 확인하세요.</p>

<h2>기본 비트 전송률 설정<a name="PreferredBitrate"></a></h2>

<p>iOS용 Brightcove Player SDK는 비디오의 기본 비트 전송률을 설정하는 방법을 제공합니다. 당신은 만들 수 있습니다<a href="Classes/BCOVPreferredBitrateConfig.html"> BCOVPreferredBitrateConfig</a>옵션을 표시하기 위해 생성된 뷰 컨트롤러에 대한 일부 구성과 함께 원하는 비트 전송률 옵션이 포함된 개체입니다.</p>

<p>메뉴 제목은 선택 사항입니다. 비트 전송률 옵션은 NSDictionary의 배열입니다. &rsquo;각 사전에는 하나의 키:값 쌍이 있습니다. 키는 옵션 이름으로 사용되며 값은 해당 옵션의 비트 전송률이 bps(초당 비트 수)인 NSNumber입니다. 입력한 비트 전송률은 비디오 자산의 변환 비트 전송률에 매핑할 수 있는 값입니다. 에서 변환에 대해 자세히 알아볼 수 있습니다. <a href="https://studio.support.brightcove.com/admin/ingest-profiles-best-practices.html">프로필 수집 모범 사례</a> .</p>

<p>다음은 예입니다.</p>

<pre><code>BCOVPUIPlayerViewOptions *options = [[BCOVPUIPlayerViewOptions 할당] 초기화]; options.preferredBitrateConfig = [BCOVPreferredBitrateConfig configWithMenuTitle:@"옵션 선택" 및BitrateOptions:@[@ {@"Auto":@(0)} , @ {@"Setting 1":@(aBitrateValue)} , @ {@"Setting 2":@(aBitrateValue)} ]];</code></pre>

<p>최종 사용자가 옵션 중 하나를 선택하면<a href="https://developer.apple.com/documentation/avfoundation/avplayeritem/1388541-preferredpeakbitrate">선호 피크 비트율</a>현재 AVPlayerItem의 속성이 옵션으로 설정됩니다. &rsquo;값. 비디오가 재생 목록에 있는 경우 재생되는 다음 비디오에도 preferredPeakBitRate 값이 설정됩니다.</p>

<p>에 대해 0이 아닌 값을 설정한 후<a href="https://developer.apple.com/documentation/avfoundation/avplayeritem/1388541-preferredpeakbitrate">선호 피크 비트율</a> AVPlayer가 현재 버퍼링된 캐시의 끝에 도달할 때까지 품질의 차이를 느끼지 못할 수도 있습니다.</p>

<p>당신은 추가로 사용할 수 있습니다<code> configWithMenuTitle:bitrateOptions:andIndexofInitialSelection:</code>선호하는 초기 값의 인덱스를 설정하는 기능을 제공하는 이니셜라이저. 인덱스는 원하는 옵션의 인덱스와 상관관계가 있어야 합니다. <code>비트 전송률 옵션</code>정렬.</p>

<p>당신은 추가로 사용할 수 있습니다<code> setPreferredPeakBitRate:</code>당신의 방법<a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a>현재 및 미래 세션에 대해 기본 비트 전송률을 프로그래밍 방식으로 설정하는 개체입니다.</p>

<p>노트: 최종 사용자는 기본값(0)으로 돌아갈 수 있는 방법을 제공해야 합니다. <a href="https://developer.apple.com/documentation/avfoundation/avplayeritem/1388541-preferredpeakbitrate">선호 피크 비트율</a> . 비트 전송률 값이 0인 옵션을 제공하여 이를 수행할 수 있습니다. 0의 비트 전송률 옵션을 제공하지 않으면&ldquo;자동적 인&rdquo;옵션은 최종 사용자를 위한 옵션 목록에 추가됩니다.</p>

<p>애플을 봐주세요&rsquo;에 대한 문서<a href="https://developer.apple.com/documentation/avfoundation/avplayeritem/1388541-preferredpeakbitrate">선호 피크 비트율</a>자세한 내용은.</p>

<h2>콘텐츠 및 광고 재생 정보 얻기<a name="PlaybackInformation"></a></h2>

<p>iOS용 Brightcove Player SDK는 재생 정보를 얻기 위한 두 가지 메커니즘을 제공합니다. 재생 컨트롤러는 다음을 구현하는 대리자 속성을 제공합니다. <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L667-L793"> [ <code> BCOVPlaybackControllerDelegate</code> ](프로토콜/BCOVPlaybackControllerDelegate.html)</a> . 대리자는 이러한 선택적 메서드를 구현하여 진행률, 기간 변경 및 기타 이벤트와 같은 재생 메타데이터에 대한 알림을 받을 수 있습니다. 광고 플러그인이 설치된 경우 이 대리자를 사용하여 다음 정보를 제공할 수도 있습니다. <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVAdvertising.h#L120-L192">광고 재생</a> . NS <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L630-L641">수명 주기 이벤트</a>대리자 메서드는 재생 상태의 변경 사항을 알리는 이벤트를 제공합니다. 예를 들어 플레이어가 일시 중지 상태에서 재생 상태로 전환되면 수명 주기 이벤트 대리자 메서드가 다음과 함께 호출됩니다. <code> kBCOVPlaybackSessionLifecycleEventPlay</code>이벤트. 기본 수명 주기 이벤트는 다음에서 선언됩니다. <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackSession.h"> [ <code> BCOV재생 세션</code> ](프로토콜/BCOVPlaybackSession.html)</a> . Brightcove에서 제공하는 플러그인은 각 플러그인에 정의된 추가 수명 주기 이벤트를 추가합니다.</p>

<p>재생 컨트롤러는 단일 대리자를 허용합니다. 많은 경우에 이것은 정보를 검색하기에 충분할 것입니다. 대리자 구현은 필요에 따라 앱의 다른 부분에 값과 이벤트를 보급할 수 있습니다. 플러그인을 개발할 때와 같이 여러 대리자가 필요한 경우<a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L538-L655"> [ <code> BCOVPlaybackSessionConsumer</code> ](프로토콜/BCOVPlaybackSessionConsumer.html)</a>대리자는 동일한 기능을 제공합니다. <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L667-L793"> [ <code> BCOVPlaybackControllerDelegate</code> ](프로토콜/BCOVPlaybackControllerDelegate.html)</a>다음을 포함한 방법<a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVAdvertising.h#L195-L259">광고 데이터</a> .</p>

<p>다음은 사용할 수 있는 방법의 예입니다. <a href="Protocols/BCOVPlaybackSessionConsumer.html"><code> BCOVPlaybackSessionConsumer</code></a>분석 플러그인을 생성하려면:</p>

<pre><code>@interface XYZAnalytics : NSObject BCOVPlaybackSessionConsumer @end @implementation XYZAnalytics - (void)playbackSession:(idBCOVPlaybackSession)세션 didProgressTo:(NSTimeInterval)progress { //react to progress event } @끝</code></pre>

<p>플러그인을 사용하려면:</p>

<pre><code>BCOVPlayerSDKManager *sdkManager = [BCOVPlayerSDKManager 공유 관리자]; id&lt;BCOVPlaybackController&gt; 컨트롤러 = [sdkManager createPlaybackController]; XYZAnalytics *analytics = [[XYZAnalytics 할당] 초기화]; [컨트롤러 addSessionConsumer:분석];</code></pre>

<h2>네트워크 중단 및 속도 저하 처리<a name="HandlingNetworkInterruptionsAndSlowdowns"></a></h2>

<p>응용 프로그램에서 네트워크 중단이 발생하면<code> AVPlayer</code>에 의해 사용<a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a>중단이 너무 오래 지속되면 복구 시도를 중지할 수 있습니다. 이 경우 수명 주기 대리자 메서드가 다음과 함께 호출됩니다. <code> kBCOVPlaybackSessionLifecycleEventFailedToPlayToEndTime</code>이벤트. 이 이벤트가 발생하면 재생<strong> ~하지 않을 것이다</strong>자동으로 복구합니다. 이 이벤트에서 복구하려면 클라이언트 코드에서 네트워크가 복구되는 시기를 감지해야 합니다.</p>

<p>네트워크가 복구되었다고 판단되면 다음을 사용할 수 있습니다. <code> - [</code> [BCOVPlaybackController resumeVideoAtTime:withAutoPlay:] <code> ](프로토콜/BCOVPlaybackController.html#//api/name/resumeVideoAtTime:withAutoPlay:)</code>플레이어를 다시 초기화합니다. 다시 시작하려는 위치를 추적해야 합니다. 플레이어는 광고 재생 또는 분석 방해를 방지하기 위해 수명 주기 이벤트 및 진행 이벤트를 억제하기 위해 최선을 다할 것입니다.</p>

<p>호출 시<code> - [</code> [BCOVPlaybackController resumeVideoAtTime:withAutoPlay:] <code> ](프로토콜/BCOVPlaybackController.html#//api/name/resumeVideoAtTime:withAutoPlay:)</code> , 플레이어는 유형의 수명 주기 이벤트를 보냅니다. <code> kBCOVPlaybackSessionLifecycleEventResumeBegin</code> . <code> kBCOVPlaybackSessionLifecycleEventResumeComplete</code>이 작업이 성공하면 전송되고, 그렇지 않으면<code> kBCOVPlaybackSessionLifecycleEventResumeFail</code>전송됩니다.</p>

<p>전화하기 전에 기다려야합니다<code> - [</code> [BCOVPlaybackController resumeVideoAtTime:withAutoPlay:] <code> ](프로토콜/BCOVPlaybackController.html#//api/name/resumeVideoAtTime:withAutoPlay:)</code>둘 중 하나를 받을 때까지 두 번째로<code> kBCOVPlaybackSessionLifecycleEventResumeComplete</code>또는<code> kBCOVPlaybackSessionLifecycleEventResumeFail</code>이전 통화에서. 사용자에게 네트워크가 너무 불안정하다는 메시지를 주기 전에 재시도 제한을 적용할 수 있습니다.</p>

<p>때<code> AVPlayer</code>여전히 네트워크에 액세스할 수 있지만 네트워크가 너무 느리기 때문에 비디오가 중단됩니다. 수명 주기 대리자 메서드는 다음과 함께 호출됩니다. <code> kBCOVPlaybackSessionLifecycleEventPlaybackStalled</code>이벤트. 재생을 재개할 수 있으면 수명 주기 대리자 메서드가 다음과 함께 호출됩니다. <code> kBCOVPlaybackSessionLifecycleEventPlayback복구됨</code>이벤트. 이러한 이벤트는 일반 재생이 중지된 경우에만 적용되며 비디오 탐색 또는 초기 로드 중에 발생하는 버퍼링은 다루지 않습니다.</p>

<p>비디오가 처음 로드될 때, 탐색이 발생하거나 느린 네트워크로 인해 재생이 중단되면 수명 주기 대리자 메서드가 다음과 함께 호출됩니다. <code> kBCOVPlaybackSessionLifecycleEventPlaybackBufferEmpty</code>이벤트. 재생을 재개할 수 있으면 수명 주기 대리자 메서드가 다음과 함께 호출됩니다. <code> kBCOVPlaybackSessionLifecycleEventPlaybackLikelyToKeepUp</code>이벤트.</p>

<h2>서브클래싱<a name="Subclassing"></a></h2>

<p>달리 명시적으로 문서화된 경우를 제외하고 iOS용 Player SDK의 어떤 클래스도 서브클래싱되도록 설계되지 않았습니다. 서브클래싱되도록 명시적으로 설계되지 않은 SDK 클래스의 서브클래스, 특히 값 클래스를 생성하면 예측할 수 없는 동작이 발생할 수 있습니다.</p>

<h2>가치<a name="Values"></a></h2>

<p>또한 ~으로 알려진&ldquo;모델 객체&rdquo; , 이러한 클래스( <a href="Classes/BCOVPlaylist.html"><code> BCOV재생 목록</code></a> , <a href="Classes/BCOVVideo.html"><code> BCOV비디오</code></a> , <a href="Classes/BCOVSource.html"><code> BCOV 소스</code></a> , <a href="Classes/BCOVCuePoint.html"><code> BCOVCuePoint</code></a> , <a href="Classes/BCOVCuePointCollection.html"><code> BCOVCuePoint 컬렉션</code></a> )는 iOS용 Player SDK에서 데이터를 나타내는 데 사용됩니다. 이러한 데이터 유형은 다음과 같이 취급된다는 점을 이해하는 것이 중요합니다. <em>가치</em>, 보다는 <em>신원</em>. 이것은 정확히 동일한 데이터를 가진 값 클래스의 두 인스턴스가 있는 경우 기술적으로 별도의 메모리 주소에 있는 두 개의 서로 다른 객체임에도 불구하고 동일한 아이디어 또는 값을 나타냅니다. 즉, SDK 코드와 클라이언트 코드 모두 ID 비교( &ldquo;포인터 평등&rdquo; ) 값 개체와 함께. 대신 각 값 클래스는<code> -는 같다:</code>클래스별 동등 메서드 오버로드를 제공하며, 둘 중 하나를 대신 사용해야 합니다.</p>

<p>이것은 나쁘다:</p>

<pre><code>if (myVideo == session.video) // 버그로 이어질 수 있습니다!</code></pre>

<p>다음은 훌륭하고 기능적으로 동일합니다.</p>

<pre><code>if ([myVideo isEqualToVideo:session.video]) if ([myVideo isEqual:session.video])</code></pre>

<p>iOS용 Player SDK의 내부는 값을 메모하거나 방어적인 복사본을 만드는 것과 같은 작업을 수행할 수 있으므로 포인터 주소에 의존하여 평등을 확인하는 것은 결국 고통을 야기할 것입니다.</p>

<p>iOS용 Player SDK의 가치 클래스의 또 다른 품질은 다음과 같습니다. <em>불변</em>. 값의 인스턴스가 있으면 예측할 수 없는 동작으로 이어질 수 있으므로 이 불변성을 전복시키려고 해서는 안 됩니다. 코드에서 원하는 경우&ldquo;수정하다&rdquo;어떤 식으로든 가치가 있는 경우 유일한 수단은 새로운 가치를 만드는 것입니다. 고객의 편의를 위해&ldquo;수정&rdquo;가치, 각 가치 등급이 제공하는<code> -업데이트:</code>원래 값의 변경 가능한 복사본에 대해 작업할 수 있는 블록을 사용하는 메서드입니다.</p>

<p>다음은 이 방법을 사용하여 생성하는 예입니다. &ldquo;수정&rdquo;기존 비디오 개체의 버전이지만 속성이 다릅니다.</p>

<pre><code>BCOV비디오 *비디오1; // (속성에는 값이 "bar"인 키 "foo"가 포함됨) BCOVVideo *video2 = [video1 update:^(idBCOVMutableVideo mutable) { mutable.properties = @{ @"foo": @"bar" } ; }]; NSLog(@"foo는 %@", video1.properties[@"foo"]); // "foo is bar" 출력 NSLog(@"foo is %@", video2.properties[@"foo"]); // "foo is quux"를 출력합니다. // video1과 video2 모두 여전히 변경할 수 없는 객체입니다. video1.properties = otherDictionary; // 컴파일러 오류 발생 video2.properties = otherDictionary; // 컴파일러 오류 발생</code></pre>

<p>예에서 볼 수 있듯이, <code>비디오1</code>에 의해 변경되지 않았습니다. <code> -업데이트</code>메소드 호출. 대신 이 메서드는 다음의 복사본을 반환합니다. <code>비디오1</code> , 블록 본문에서 수정한 사항을 제외하고. 변경 가능한 복사본이 블록을 탈출하도록 허용해서는 안 됩니다(예: <code> __블록</code>변수) 대신에<code> -업데이트</code>방법을 수정한 후.</p>

<h2>재생 서비스를 사용하여 Brightcove 자산 검색<a name="PlaybackService"></a></h2>

<p>재생 서비스 클래스, <a href="Classes/BCOVPlaybackService.html"><code> BCOV재생 서비스</code></a> , 다음을 통해 Brightcove 비디오 자산 및 재생 목록을 검색하는 기능을 제공합니다. <a href="https://apis.support.brightcove.com/playback/getting-started/overview-playback-api.html">브라이트코브 재생 API</a> , 텍스트 트랙, 미리보기 및 축소판과 같은 풍부한 메타데이터를 포함합니다. 다음 예는 비디오 ID로 비디오를 검색하는 방법을 보여줍니다. 해당 비디오와 함께 비디오 또는 재생 목록을 검색하는 방법&rsquo;참조 ID도 사용할 수 있습니다.</p>

<pre><code>[1] NSString *policyKey = &lt;your-policy-key&gt;; NSString *accountId = &lt;your-account-id&gt;; NSString *videoID = &lt;your-video-id&gt;; BCOVPlayerSDKManager *manager = [BCOVPlayerSDKManager sharedManager]; id&lt;BCOVPlaybackController&gt; controller = [manager createPlaybackControllerWithViewStrategy:nil]; [self.view addSubview:controller.view]; BCOVPlaybackService *playbackService = [[BCOVPlaybackService alloc] initWithAccountId:accoundId policyKey:policyKey]; [playbackService findVideoWithVideoID:videoID parameters:nil completion:^(BCOVVideo *video, NSDictionary *jsonResponse, NSError *error) { [controller setVideos:@[ video ]]; [controller play]; }]; </code></pre>

<ol>
<li>재생 서비스 요청<strong>정책 키</strong>인증을 위해. 정책 키 및 얻는 방법에 대한 자세한 내용은 다음을 참조하십시오. <a href="https://apis.support.brightcove.com/policy/getting-started/policy-keys.html">정책 키 문서</a> .</li>
</ol>


<p>**노트: 재생 승인 서비스를 사용하는 경우 검토하십시오. <a href="#PlaybackAuthorizationService">부분</a>해당 기능과 관련된 이 README의 내용입니다.</p>

<p><strong>재생 목록 페이징</strong></p>

<p>을위한<code></code>재생 목록을 반환하는 BCOVPlaybackService` 메서드, 부분 재생 목록을 요청할 수 있습니다. 또는&ldquo;페이지&rdquo;매개변수 사전에서 한계 및 오프셋 매개변수를 지정하여 재생 목록에서 제한은 반환될 최대 비디오 수를 지정하고 오프셋은 비디오가 반환될 재생 목록의 인덱스를 지정합니다.</p>

<p>예를 들어 100개의 동영상이 있는 재생목록이 있는 경우 다음과 같이 동영상 10번부터 시작하여 6개의 동영상만 요청할 수 있습니다.</p>

<pre><code> NSDictionary *parameters = @{ @"limit": @6, @"offset": @10 }; [playbackService findPlaylistWithPlaylistID:playlistID parameters: parameters completion:^(BCOVPlaylist *playlist, NSDictionary *jsonResponse, NSError *error) { [controller setVideos: playlist]; [controller play]; }]; </code></pre>

<h2>전략 보기<a name="ViewStrategy"></a></h2>

<p>NS <a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a>개체는 SDK의 클라이언트로서 재생 컨트롤러에서 반환되는 정확한 UIView 개체를 정의할 수 있는 보기 전략으로 구성됩니다. &rsquo;보기 속성입니다. 이것은 재생 컨트롤러에 영향을 주는 플러그인을 사용할 때 중요합니다. &rsquo;동영상 보기를 광고 보기와 오버레이하는 광고 플러그인과 같은 보기. 많은 앱은 보기 전략을 만들 필요가 없으며 단순히 통과할 수 있습니다. <code>무</code>새 재생 컨트롤러를 만들 때. 그러면 재생 컨트롤러에서 표준 비디오 보기가 생성됩니다.</p>

<p>NS <a href="Blocks/BCOVPlaybackControllerViewStrategy.html"><code> BCOVPlaybackControllerView전략</code></a> typedef 별칭(및 문서)이 더 복잡한 블록 서명:</p>

<p><code>objc UIView *(^)(UIView *videoView, idBCOVPlaybackController 재생 컨트롤러);</code></p>

<p>이 서명은 UIView를 반환하고 UIView와 재생 컨트롤러의 두 매개변수를 사용하는 Objective-C 블록을 설명합니다. 반환 값은 재생 컨트롤러가&rsquo; s view 속성이 가리킬 것입니다. 첫 번째 매개변수는 비디오 레이어를 포함하는 UIView이며, UIView는 비디오를 표시합니다. 두 번째 매개변수는 보기 전략이 제공된 재생 컨트롤러 개체이며 재생 컨트롤러를 사용하여 비디오 컨트롤 또는 광고 컨트롤과 같은 필요한 세션 소비자를 추가할 수 있습니다.</p>

<p>보기 전략 구현의 예:</p>

<p>```objc BCOVPlaybackControllerViewStrategy viewStrategy = ^(UIView *videoView, id<BCOVPlaybackController> 재생 컨트롤러) {</p>

<pre><code>// Create some custom controls for the video view, // and compose both into a container view. [1] UIView&lt;BCOVPlaybackSessionConsumer&gt; *myControlsView = [[MyControlsView alloc] init]; [2] UIView *controlsAndVideoView = [[UIView alloc] init]; [3] [controlsAndVideoView addSubview:videoView]; [controlsAndVideoView addSubview:myControlsView]; // Compose the container with an advertising view // into another container view. [4] UIView&lt;BCOVPlaybackSessionConsumer&gt; *adView = [[SomeAdPluginView alloc] init]; [5] UIView *adAndVideoView = [[UIView alloc] init]; [6] [adAndVideoView addSubview:controlsAndVideoView]; [adAndVideoView addSubview:adView]; [7] [playbackController addSessionConsumer:myControlsView]; [playbackController addSessionConsumer:adView]; // This container view will become `playbackController.view`. return adAndVideoView; </code></pre>

<p>}; <code>`` Breaking the code down into steps: [1] Create a custom controls view that conforms to the </code>BCOVPlaybackSessionConsumer<code> protocol. </code> BCOVPlaybackSessionConsumer <code>프로토콜을 통해 광고 외에 각 동영상에 대한 기본 재생 정보를 수신할 수 있습니다. [2] 비디오 보기 및 사용자 정의 컨트롤에 대한 컨테이너 보기를 만듭니다. [3] 비디오 컨테이너와 사용자 정의 컨트롤을 하위 보기로 추가합니다. 계층 구조는 보기가 추가되는 것과 같은 순서로 구성됩니다. [4] 다음을 준수하는 광고 컨트롤 보기 만들기</code> BCOVPlaybackSessionConsumer` 프로토콜. [5] 비디오 보기 및 컨트롤, 광고 보기에 대한 컨테이너 보기를 만듭니다. [6] 비디오 컨테이너 및 광고 컨트롤 보기를 하위 보기로 추가합니다. [7] 사용자 정의 컨트롤 보기와 광고 컨트롤 보기를 블록에서 반환된 재생 컨트롤러 개체를 사용하여 세션 소비자로 등록합니다.</p>

<p>보기 전략을 사용할 때 한 가지 주의할 점이 있습니다. 재생 컨트롤러에 액세스하면 안 됩니다. &rsquo; NS <code>보다</code>보기 전략 블록 내에서 속성. 블록이 호출되기 때문에 <em>왜냐하면</em> 재생 컨트롤러&rsquo; NS <code>보다</code>속성에 처음으로 액세스하여 액세스<code>보다</code>다시 재산 <em>이내에</em> 보기 전략 블록으로 인해 프로그램이 중단됩니다.</p>

<h2>백그라운드에서 비디오 재생<a name="BackgroundVideo"></a></h2>

<p>기본적으로 iOS 애플리케이션이 백그라운드로 전송되거나 기기가 잠겨 있으면 iOS는 재생 중인 모든 비디오를 일시 중지합니다. 이 동작을 변경하려면 다음을 설정하십시오. <code>배경 오디오 재생 허용</code>재산<a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a>반대하다<code>예</code> . (기본값은<code>아니요</code> , 재생이 백그라운드에서 일시 중지됨을 나타냅니다.)</p>

<p>또한 Apple에서 설정한 지침을 따라야 합니다. <a href="https://developer.apple.com/library/ios/qa/qa1668">기술 Q&amp;A QA1668</a>앱에 적절한 배경 모드와 오디오 세션 카테고리를 설정합니다.</p>

<p>그것&rsquo;중요한 것은<code> AVPlayer 레이어</code>에서 분리되다<code> AVPlayer</code>앱이 백그라운드로 전환되기 전(앱이 포그라운드로 돌아갈 때 다시 연결됨). Brightcove Player SDK는 다음과 같은 경우 이를 처리합니다. <code>배경 오디오 재생 허용</code>로 설정됩니다<code>예</code> .</p>

<p>마지막으로, 배경 비디오를 재생할 때(특히 재생 목록을 사용할 때) iOS를 사용해야 합니다. <code> MPRemoteCommandCenter</code>잠금 화면과 제어 센터에서 사용자에게 재생 제어를 제공하는 API입니다.</p>

<h2>화면 속 화면<a name="PIP"></a></h2>

<p>애플리케이션에서 PIP(Picture-in-Picture)를 활성화하려면<code>픽쳐 인 픽쳐 버튼을 보여주세요</code>재산<a href="Classes/BCOVPUIPlayerViewOptions.html"><code> BCOVPUIPlayerViewOptions</code></a>반대하다<code>예</code>인스턴스화할 때<a href="Classes/BCOVPUIPlayerView.html"><code> BCOVPUIPlayerView</code></a>물체. 그러면 Picture-in-Picture 버튼이 지원하는 모든 장치의 컨트롤 막대에 표시됩니다.</p>

<p>Picture-in-Picture가 제대로 작동하려면 다음을 확인해야 합니다. <code>오디오, AirPlay 및 PIP(Picture in Picture)</code>모드는<code>배경 모드</code>프로젝트의 대상 기능 탭 섹션. 또한 Apple에서 설정한 지침을 따라야 합니다. <a href="https://developer.apple.com/library/ios/qa/qa1668">기술 Q&amp;A QA1668</a>앱에 적절한 배경 모드와 오디오 세션 카테고리를 설정합니다.</p>

<p>NS <code> AVPictureInPictureControllerDelegate</code>메서드는 다음을 통해 전달됩니다. <a href="Protocols/BCOVPUIPlayerViewDelegate.html"><code> BCOVPUIPlayerViewDelegate</code></a> . 이러한 방법은 다음과 같습니다.</p>

<pre><code>- (void)pictureInPictureControllerDidStartPictureInPicture:(AVPictureInPictureController *)pictureInPictureController; - (void)pictureInPictureControllerDidStopPictureInPicture:(AVPictureInPictureController *)pictureInPictureController; - (void)pictureInPictureControllerWillStartPictureInPicture:(AVPictureInPictureController *)pictureInPictureController; - (void)pictureInPictureControllerWillStopPictureInPicture:(AVPictureInPictureController *)pictureInPictureController; - (void)pictureInPictureController:(AVPictureInPictureController *)pictureInPictureController failedToStartPictureInPictureWithError:(NSError *)error - (void)pictureInPictureController:(AVPictureInPictureController *)pictureInPictureController restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:(void (^)(BOOL))completionHandler; </code></pre>

<p>애플 참조&rsquo; NS <a href="https://developer.apple.com/documentation/avkit/avpictureinpicturecontrollerdelegate"> AVPictureInPictureControllerDelegate</a>자세한 내용은 설명서를 참조하십시오.</p>

<p>자신의 PIP(Picture-in-Picture) 동작을 구현하려면<code> PictureInPictureActive</code>의 재산<a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a> PIP(Picture-in-Picture) 상태로 업데이트되었습니다. 사용 중인 경우<code> AVPictureInPictureController</code> , 당신은 사용할 수 있습니다<code> PictureInPictureControllerDidStartPictureInPicture:</code>그리고<code> PictureInPictureControllerDidStopPictureInPicture:</code>이 속성을 업데이트하는 대리자 메서드.</p>

<p>Apple에서 PIP(Picture-in-Picture)를 구현하는 방법에 대해 자세히 알아볼 수 있습니다. &rsquo; NS <a href="https://developer.apple.com/documentation/avkit/adopting_picture_in_picture_in_a_custom_player">사용자 지정 플레이어에서 PIP(Picture in Picture) 채택</a>선적 서류 비치.</p>

<p>PIP(Picture-in-Picture)와 혼합 형식의 비디오 재생 목록을 사용하면 각 비디오 사이에 PIP(Picture-in-Picture) 창이 닫힙니다.</p>

<p>iOS 및 iPadOS 14에서 켜기/끄기로 전환할 수 있는 자동 PIP(Picture-in-Picture) 동작이 도입되었습니다. <code>설정 &gt; 일반 &gt; 화면 속 화면</code> . 이 기능이 예상대로 작동하려면 플레이어 보기가 화면 너비와 같아야 하고 높이가 너비에 대한 비율(16:9 이상) 이상이어야 합니다. 플레이어 보기의 너비 또는 높이가 이 값보다 작으면 응용 프로그램이 배경에 들어갈 때 PIP(Picture-in-Picture)가 자동으로 트리거되지 않을 수 있습니다.</p>

<p><strong>중요한 : 브라이트코브 네이티브 플레이어 SDK &rsquo;■ PIP(Picture-in-Picture) 기능은 광고 재생이 있는 비디오를 지원하지 않습니다. PIP(Picture-in-Picture) 기능이 활성화된 광고와 함께 비디오를 사용하려고 하면 예기치 않은 동작이 발생합니다.</strong></p>

<h2>썸네일 찾기<a name="ThumbnailSeeking"></a></h2>

<p>썸네일 검색을 통해 사용자는 타임라인을 따라 재생 헤드를 드래그하고 관련 콘텐츠의 미리보기로 썸네일을 볼 수 있습니다. 이를 통해 사용자는 비디오 파일을 빠르게 탐색하고 관심 있는 콘텐츠를 찾을 수 있습니다.</p>

<p>이 기능은 Apple에서 Trick Play라고도 하며 해당 기능에서 참조됩니다. <a href="https://developer.apple.com/documentation/http_live_streaming/hls_authoring_specification_for_apple_devices?language=objc"> HLS 저작 사양</a> .</p>

<p>이 기능은 기본적으로 활성화되어 있습니다. 썸네일 검색을 비활성화하려면 다음을 설정하여 수행할 수 있습니다. <code>미리보기 이미지</code>당신의 재산<a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a>에게<code>아니요</code> .</p>

<pre><code>self.playbackController.thumbnailSeekingEnabled = 아니요;</code></pre>

<p>델리게이트 메소드를 사용하여 썸네일 미리보기의 레이아웃을 사용자 정의할 수 있습니다. <a href="Classes/BCOVPUIPlayerView.html"><code> BCOVPUIPlayerView</code></a>또는<a href="Classes/BCOVTVPlayerView.html"><code> BCOVTVPlayerView</code></a> .</p>

<p>iOS에서는 높이, 너비 및 수직 오프셋을 조정할 수 있습니다.</p>

<pre><code>- (void)setupPlayerView { BCOVPUIPlayerView *playerView = [[BCOVPUIPlayerView alloc] initWithPlaybackController:nil]; playerView.delegate = self; ... } #pragma mark - BCOVPUIPlayerViewDelegate - (CGRect)playerViewShouldDisplayThumbnailPreviewWithRect:(BCOVPUIPlayerView *)playerView { CGFloat width = 100; CGFloat height = 56; CGFloat verticalOffset = -60; CGFloat modifier = 1; if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) { modifier = 2; } return CGRectMake(0, verticalOffset * modifier, width * modifier, height * modifier); } </code></pre>

<p>tvOS에서는 높이와 너비를 조정할 수 있습니다.</p>

<pre><code>- (void)setupPlayerView { self.playerView = [[BCOVTVPlayerView alloc] initWithOptions:nil]; self.playerView.delegate = self; ... } #pragma mark - BCOVTVPlayerViewDelegate - (CGSize)playerViewShouldDisplayThumbnailPreviewWithSize:(BCOVTVPlayerView *)playerView { CGSize size = self.view.frame.size; size.width = size.width / 6; size.height = size.height / 6; return size; } </code></pre>

<p>수동으로 구성하는 경우<a href="Classes/BCOVVideo.html"><code> BCOV비디오</code></a> I-FRAME 소스에 사용할 URL을 설정할 수 있습니다.</p>

<pre><code>BCOVVideo *비디오 = [BCOVVideo videoWithURL:[NSURL URLWithString:@"https://mydomain.com/master.m3u8"]]; 비디오 = [비디오 업데이트:^(id&lt;BCOVMutableVideo&gt; mutableVideo) { mutableVideo.iFramePlaylistURL = [NSURL URLWithString:@"https://mydomain.com/iframe.m3u8"]; } ];</code></pre>

<p>썸네일 스크러빙은 온라인 비디오에만 사용할 수 있습니다. 다운로드/오프라인 동영상은 이 기능을 지원하지 않습니다.</p>

<h2>추적 오류<a name="TrackingErrors"></a></h2>

<p>재생 오류는 일반적으로 재생 컨트롤러의 비디오 재생 이벤트를 통해 처리되고 보고됩니다. 특정 비디오 또는 앱 세션에 대해 더 깊이 파고들어 문제를 추적해야 하는 경우 Brightcove Player SDK를 활용할 수 있습니다. &rsquo; NS <em>세션 ID</em>. 세션 ID는<a href="Classes/BCOVPlayerSDKManager.html"><code> BCOVPlayerSDKManager</code></a>다음과 같이 검색할 수 있습니다.</p>

<pre><code>NSString *sdkSessionID = BCOVPlayerSDKManager.sharedManager.sessionID;</code></pre>

<p>세션 ID는 앱 수명 주기 동안 변경되지 않는 고유한 문자열입니다. 이 문자열은 다양한 기타 분석 데이터와 함께 Brightcove 메트릭 서버에 보고됩니다. 특정 앱 인스턴스 또는 비디오에 문제가 있는 경우 세션 ID를 기록하고 회사 서버로 다시 보낼 수 있습니다. 그런 다음 세션 ID, 비디오 ID 및 기타 관련 데이터를 Brightcove 서비스 엔지니어에게 보내 문제를 진단할 수 있습니다.</p>

<h2>플러그인 결합<a name="CombiningPlugins"></a></h2>

<p>예를 들어 Google IMA에서 관리하는 광고를 재생하는 DRM으로 보호된 동영상에 자막을 추가하기 위해 Player SDK 플러그인을 결합해야 하는 경우, <code> BCOV세션 제공자</code>각 플러그인에서 생성되고 함께 연결되며 체인은 구성하는 데 사용됩니다. <a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a> .</p>

<pre><code>BCOVPlayerSDKManager *sdkManager = [BCOVPlayerSDKManager 공유 관리자]; IMASettings *imaSettings = [[IMASettings 할당] 초기화]; imaSettings.ppid = kViewControllerIMAPublisherID; imaSettings.language = kViewControllerIMALanguage; imaSettings.enableBackgroundPlayback = self.allowBackgroundAudioPlayback; IMAAdsRenderingSettings *renderSettings = [[IMAAdsRenderingSettings 할당] 초기화]; renderSettings.webOpenerPresentingController = 자기; BCOVIMAAdsRequestPolicy *adsRequestPolicy = [BCOVIMAAdsRequestPolicy videoPropertiesVMAPAdTagUrlAdsRequestPolicy]; // 사이드카 자막 세션 제공자를 생성합니다. 업스트림 세션 공급자가 없습니다. id&lt;BCOVPlaybackSessionProvider&gt; *sidecarSessionProvider = [sdkManager createSidecarSubtitlesSessionProviderWithUpstreamSessionProvider:nil]; // 업스트림 사이드카 자막 세션 제공자를 사용하여 IMA 세션 제공자를 생성합니다. id&lt;BCOVPlaybackSessionProvider&gt; *imaSessionProvider = [sdkManager createIMASessionProviderWithSettings:imaSettings adsRenderingSettings:renderSettings adsRequestPolicy:adsRequestPolicy adContainer:self.playerView.contentOverlayView 동반자 슬롯:nil upstreamSessionProvider:sidecarSessionProvider]; // 세션 공급자 체인을 사용하여 재생 컨트롤러를 만듭니다. id&lt;BCOVPlaybackController&gt; *playbackController = [sdkManager createPlaybackControllerWithSessionProvider:imaSessionProvider viewStrategy:nil];</code></pre>

<h1>버퍼 최적화<a name="BufferOptimization"></a></h1>

<h2>개요</h2>

<p>개발자는<code> AVPlayer</code> . 이것은 설정하여 수행됩니다<code>우선포워드버퍼지속시간</code>재산<code> AVPlayer아이템</code>수업.</p>

<p>기본적으로 Brightcove Native Player SDK는<code>우선포워드버퍼지속시간</code>재생 품질을 희생하지 않고 전체 대역폭을 최적화하는 방식으로 속성을 변경합니다. 이 동작은 자신의 값으로 재정의할 수 있습니다.</p>

<h2>기본 동작</h2>

<p>모든 사람이 대역폭에 대해 비용을 지불하므로&rsquo;재생 품질에 영향을 주지 않고 대역폭 소비를 줄이는 것이 중요합니다. 버전 5.2.0의 새로운 기능인 Brightcove Native Player SDK는 동영상이 재생될 때 버퍼 크기를 동적으로 관리합니다.</p>

<p>iOS 10 이전에는<code> AVPlayer</code>최대 약 50MB까지 가능한 한 많은 비디오 데이터를 버퍼링합니다. 이것은 사용자가 비디오를 선택하고 끝까지 시청하는 비디오 보기 모델에 적합하지만 현재 많은 최신 앱이&ldquo;놀리다&rdquo;몇 초 후에 참여를 확보하기 위해 자동 재생 기능이 있는 동영상. 많은 사용자가 단순히 다른 비디오로 이동합니다. 적극적인 버퍼링을 사용하면 각 비디오 노출과 함께 버려지는 몇 분의 버퍼링된 비디오로 끝날 수 있습니다.</p>

<p>Brightcove Native Player SDK는 작은 기준 버퍼로 비디오를 시작한 다음 사용자가 비디오를 더 많이 볼수록 증가시켜 이 문제를 해결합니다. 특정 시점 이후에는 버퍼 크기가 제한됩니다. 버퍼 크기를 너무 크게 만드는 것은 실용적이지 않거나 도움이 되지 않기 때문입니다.</p>

<h2>기본 동작 수정</h2>

<p>Brightcove Native Player SDK의 기본 동작을 유지하되 버퍼 크기에 사용되는 최소값 및 최대값을 수정하려는 경우 설정할 때 다음을 수행할 수 있습니다. <a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a> :</p>

<pre><code>// 새로운 값을 담기 위한 가변 사전 생성 NSMutableDictionary *options = self.playbackController.options.mutableCopy; // 사전에 새로운 값 설정 options[kBCOVBufferOptimizerMethodKey] = @(BCOVBufferOptimizerMethodDefault); 옵션[kBCOVBufferOptimizerMinimumDurationKey] = @(최소); 옵션[kBCOVBufferOptimizerMaximumDurationKey] = @(최대); // 재생 컨트롤러에 새 사전 설정 self.playbackController.options = options;</code></pre>

<p>이 옵션은 호출하기 전에 설정해야 합니다. <code> -BCOVPlaybackController 세트 비디오:</code> .</p>

<p><code>분</code>그리고<code>최대</code>값:</p>

<ul>
<li>이는 새로운 최소 및 최대 버퍼 지속 시간으로 설정할 수 있는 부동 소수점 값입니다.</li>
<li>값을 너무 작게 설정하면 불규칙한 네트워크 조건에서 재생이 중단될 수 있습니다.</li>
<li>값을 너무 크게 설정하면<code> AVPlayer</code>본 적이 없는 데이터를 버퍼링할 수 있습니다.</li>
<li>예상 사용 사례를 기반으로 테스트하는 것이 중요합니다.</li>
<li>값은 초 단위로 지정되며 1.0 이상이어야 합니다. (0은 특수 값입니다. <code> AVPlayer아이템</code>그것은 말한다<code> AVPlayer</code>자체 버퍼 크기를 결정합니다.</li>
</ul>


<h2>버퍼 최적화 끄기</h2>

<p>현재 재생 세션에서 버퍼 최적화를 활성화하지 않으려면 동일한 기술을 사용할 수 있지만 최적화 방법을 다음으로 설정합니다. &ldquo;없음&rdquo;다음과 같이:</p>

<pre><code>// 새로운 값을 담기 위한 가변 사전 생성 NSMutableDictionary *options = self.playbackController.options.mutableCopy; // 사전에 새로운 값 설정 options[kBCOVBufferOptimizerMethodKey] = @(BCOVBufferOptimizerMethodNone); // 재생 컨트롤러에 새 사전 설정 self.playbackController.options = options;</code></pre>

<p>방법을 "없음"으로 설정하면 iOS가 정방향 버퍼 크기를 완전히 제어합니다.</p>

<h2>자체 버퍼 최적화 방법 구현</h2>

<p>재생을 위한 자체 버퍼 크기를 설정하려면 먼저 이전 섹션에서 설명한 대로 버퍼 최적화를 끕니다. 그런 다음 다음을 구현할 수 있습니다. <a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a>대리자 메서드:</p>

<pre><code>- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller didAdvanceToPlaybackSession:(id&lt;BCOVPlaybackSession&gt;)session { // Make sure the property exists on the current AVPlayerItem. if ([session.player.currentItem respondsToSelector:NSSelectorFromString(@"preferredForwardBufferDuration")]) { // Set your preferredForwardBufferDuration value here. session.player.currentItem.preferredForwardBufferDuration = newPreferredForwardBufferDurationValue; } } </code></pre>

<p>시간이 지남에 따라 버퍼 크기를 동적으로 변경하려면 다음을 설정할 수 있습니다. <code> session.player.currentItem.preferredForwardBufferDuration</code>에서<a href="Protocols/BCOVPlaybackController.html"><code> BCOV재생 컨트롤러</code></a>&rsquo;유사한 방식으로 진행 델리게이트 메소드:</p>

<pre><code>- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didProgressTo:(NSTimeInterval)progress { // Make sure the property exists on the current AVPlayerItem. if ([session.player.currentItem respondsToSelector:NSSelectorFromString(@"preferredForwardBufferDuration")]) { // Set preferredForwardBufferDuration based on your own logic here session.player.currentItem.preferredForwardBufferDuration = newPreferredForwardBufferDurationValue; } } </code></pre>

<p>참고: 애플은 구체적으로&ldquo;우선의&rdquo; ~에<code>우선포워드버퍼지속시간</code>원하는 값을 설정할 수 있기 때문에 일반적으로<code> AVPlayer</code>플레이어는 이것을 지침으로만 사용할 것입니다. 또한 0으로 설정하면 버퍼 크기에 대한 전체 제어가<code> AVPlayer</code> .</p>

<h1>AVPlayerViewController 사용하기<a href="Protocols/BCOVPlaybackController.html"> BCOV재생 컨트롤러</a><a name="AVPlayerViewController"></a></h1>

<h2>개요</h2>

<p>에서 사용하는 AVPlayerLayer 대신 AVPlayerViewController를 사용할 수 있습니다. <a href="Protocols/BCOVPlaybackSession.html"> BCOV재생 세션</a>수업. AVPlayerViewController를 사용하면 플레이어가 기본 iOS 및 tvOS 플레이어 컨트롤을 사용할 수 있지만 이 접근 방식에는 제한이 있습니다(아래 참조).</p>

<p>AVPlayerViewController를 사용하려면 다음을 설정할 수 있습니다. <a href="Protocols/BCOVPlaybackController.html"> BCOV재생 컨트롤러</a>이라는 사전 속성<code> kBCOVVPlayerViewControllerCompatibilityKey</code> :</p>

<pre><code>BCOVPlayerSDKManager *sdkManager = [BCOVPlayerSDKManager 공유 관리자]; idBCOVPlaybackController 재생 컨트롤러; NSMutableDictionary *mutableOptions = self.playbackController.options.mutableCopy; // AVPlayerViewController를 사용하려면 mutableOptions[kBCOVAVPlayerViewControllerCompatibilityKey] = @YES; // BCOVPlaybackSession의 AVPlayerLayer를 사용하려면 // mutableOptions[kBCOVAVPlayerViewControllerCompatibilityKey] = @NO; self.playbackController.options = mutableOptions;</code></pre>

<p>kBCOVAVPlayerViewControllerCompatibilityKey의 기본값은 @NO입니다. <a href="Protocols/BCOVPlaybackController.html"> BCOV재생 컨트롤러</a>이 사전 속성을 명시적으로 설정하지 않고 생성하면 BCOVPlaybackSession을 사용합니다. &rsquo;■ 기본적으로 AVPlayerLayer.</p>

<h2>샘플 프로젝트</h2>

<p>Brightcove iOS SDK와 함께 AVPlayerViewController를 사용하는 방법을 보여주는 샘플 프로젝트가 있습니다. 당신은 찾을 수 있습니다<a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Player/NativeControls"> iOS 샘플 프로젝트는 여기</a>그리고<a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/IMA/NativeControlsIMAPlayer_tvOS">여기에서 tvOS 샘플 프로젝트</a> .</p>

<h2>AVPlayerViewController 사용에 대한 제한 사항</h2>

<p><strong>광고하는:</strong></p>

<p>Brightcove IMA 및 FreeWheel 광고 플러그인은 AVPlayerViewController를 사용할 때 호환됩니다. AVPlayerViewController를 사용할 수 있습니다&rsquo; NS <code>콘텐츠 오버레이 보기</code>광고를 표시할 보기입니다.</p>

<p>AVPlayerViewController를 숨기거나 표시할 수 있습니다. &rsquo;광고 재생 전후의 재생 컨트롤:</p>

<pre><code>- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didEnterAdSequence:(BCOVAdSequence *)adSequence { self.avpvc.showsPlaybackControls = NO; } - (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didExitAdSequence:(BCOVAdSequence *)adSequence { self.avpvc.showsPlaybackControls = YES; } </code></pre>

<p>Brightcove SSAI 및 Pulse 광고 플러그인은 현재 AVPlayerViewController와 호환되지 않습니다.</p>

<p><strong>해석학:</strong></p>

<p>AVPlayerViewController를 사용할 때 Brightcove Analytics 서버로 전송된 video_engagement 이벤트는 player_width 및 player_height에 대해 0을 보고합니다.</p>

<h1>재생 승인 서비스<a name="PlaybackAuthorizationService"></a></h1>

<p>재생 인증 서비스를 사용하는 경우 인증 토큰을 전달할 수 있는 재생 서비스 방법을 사용해야 합니다.</p>

<pre><code>- (void)findPlaylistWithPlaylistID:(NSString *)playlistID authToken:(NSString *)authToken parameters:(NSDictionary *)parameters completion:(void (^)(BCOVPlaylist *playlist, NSDictionary *jsonResponse, NSError *error))completionHandler; - (void)findPlaylistWithReferenceID:(NSString *)referenceID authToken:(NSString *)authToken parameters:(NSDictionary *)parameters completion:(void (^)(BCOVPlaylist *playlist, NSDictionary *jsonResponse, NSError *error))completionHandler; - (void)findVideoWithVideoID:(NSString *)videoID authToken:(NSString *)authToken parameters:(NSDictionary *)parameters completion:(void (^)(BCOVVideo *video, NSDictionary *jsonResponse, NSError *error))completionHandler; - (void)findVideoWithReferenceID:(NSString *)referenceID authToken:(NSString *)authToken parameters:(NSDictionary *)parameters completion:(void (^)(BCOVVideo *video, NSDictionary *jsonResponse, NSError *error))completionHandler; </code></pre>

<p><strong>참고: 재생 목록의 경우 재생 목록의 모든 동영상이 동일한 토큰을 사용해야 합니다. 후속 릴리스에서는 재생 목록의 각 비디오에 다른 토큰을 할당할 수 있습니다. 비디오 ID와 토큰 간의 매핑을 유지 관리해야 합니다.</strong></p>

<h1>보이스오버 지원<a name="VoiceOver"></a></h1>

<p>VoiceOver는 재생 제어를 위해 즉시 지원됩니다. 기본적으로 VoiceOver가 활성화되어 있으면 BCOVPlayerUI 컨트롤 보기가 자동으로 숨겨지지 않습니다. 재생 컨트롤러에서 두 번 탭하는 VoiceOver 활성화 제스처 사용하기&rsquo; s 보기는 컨트롤 보기의 가시성을 토글합니다. 관련이 있습니다<code>접근성 힌트</code>재생 컨트롤러에 설정된&rsquo;보기. NS <code>접근성 레이블</code>애플리케이션 내에서 각 BCOVPlayerUI 컨트롤을 사용자 지정할 수 있습니다.</p>

<p>변경하려면<code>접근성 레이블</code>컨트롤 보기에 있는 모든 버튼의 값은 개체를 다음으로 설정해야 합니다. <a href="Protocols/BCOVPUIButtonAccessibilityDelegate.html"><code> BCOVPUIButtonAccessibilityDelegate</code></a>이와 같이:</p>

<pre><code>[self.playerView.controlsView setButtonsAccessibilityDelegate:self]; </code></pre>

<p>그런 다음 해당 개체가<a href="Protocols/BCOVPUIButtonAccessibilityDelegate.html"><code> BCOVPUIButtonAccessibilityDelegate</code></a>프로토콜을 구현하여<code> - (NSString *)accessibilityLabelForButton:(</code> BCOVPUI버튼<code> *) 버튼 isPrimaryState:(BOOL) isPrimaryState</code>이와 유사한 방법:</p>

<pre><code>- (NSString *)accessibilityLabelForButton:(BCOVPUIButton *)button isPrimaryState:(BOOL)isPrimaryState { switch (button.tag) { case BCOVPUIViewTagButtonPlayback: return isPrimaryState ? NSLocalizedString(@"Start Playback", nil) : NSLocalizedString(@"Stop PLayback", nil); case BCOVPUIViewTagButtonScreenMode: return isPrimaryState ? NSLocalizedString(@"Enter Fullscreen", nil) : NSLocalizedString(@"Exit Fullscreen", nil); case BCOVPUIViewTagButtonJumpBack: return nil; case BCOVPUIViewTagButtonClosedCaption: return nil; case BCOVPUIViewTagButtonVideo360: return nil; case BCOVPUIViewTagButtonPreferredBitrate: return nil; default: return nil; } } </code></pre>

<p>만약<code>무</code>값이 반환되면 기본값이 사용됩니다.</p>

<p>설정<code>접근성 힌트</code>재생 컨트롤러에서 다음과 같이 할 수 있습니다.</p>

<pre><code>self.playbackController.view.accessibilityHint = @"컨트롤을 표시하거나 숨기려면 두 번 탭하세요.";</code></pre>

<p>마찬가지로 다음을 설정할 수 있습니다. <code>접근성 레이블</code>다음과 같이 진행 슬라이더와 함께 현재 시간 및 지속 시간 레이블에서:</p>

<pre><code>self.playerView.controlsView.durationLabel.accessibilityLabelPrefix = @"총 시간"; self.playerView.controlsView.currentTimeLabel.accessibilityLabelPrefix = @"현재 시간"; self.playerView.controlsView.progressSlider.accessibilityLabel = @"타임라인";</code></pre>

<h1>중국 배달<a name="ChinaDelivery"></a></h1>

<p>중국의 재생 서비스, 메트릭 및 분석 서버에 대한 프록시 도메인을 정의하려면 다음을 설정하십시오. <code>중국프록시도메인</code>재산<a href="Classes/BCOVGlobalConfiguration.html"><code> BCOV글로벌 구성</code></a>싱글톤을 정규화된 도메인 이름으로 바꿉니다. 예를 들면 다음과 같습니다.</p>

<pre><code>BCOVGlobalConfiguration.sharedConfig.chinaProxyDomain = @"host.mydomain.com";</code></pre>

<p>Native Player SDK의 다른 서비스를 사용하기 전에 프록시 도메인 이름을 설정해야 합니다. 참조<a href="https://docs.brightcove.com/ios-sdk/Classes/BCOVGlobalConfiguration.html#//api/name/chinaProxyDomain"><em>BCOVGlobalConfiguration 클래스 참조</em></a> for details.</p>

<h1>AVAudioSession 구성<a name="AVAudioSessionConfig"></a></h1>

<p>오디오 재생과 관련하여 응용 프로그램을 수행하는 방법에 따라 특정 요구 사항에 맞게 AVAudioSession을 구성할 수 있습니다. 예를 들어 AirPlay 2 및 여러 오디오 경로를 지원하려면<a href="#AirPlay">에어플레이</a>섹션을 참조하십시오.</p>

<p>기본 AVAudioSession은 다음과 같이 구성할 수 있습니다.</p>

<pre><code>// Obj-C NSError *categoryError = nil; // see https://developer.apple.com/documentation/avfoundation/avaudiosessioncategoryplayback BOOL success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&amp;categoryError]; if (!success) { // Handle error } </code></pre>

<pre><code>// Swift var categoryError :NSError? var success: 불두{ // see https://developer.apple.com/documentation/avfoundation/avaudiosessioncategoryplayback try AVAudioSession.sharedInstance().setCategory(.playback) success = true } NSError로 오류를 잡아라. { categoryError = error success = false }성공하면{ // Handle error }</code></pre>

<p>이 구성은 일반적으로 AppDelegate에서 수행할 수 있습니다. &rsquo; NS <code>응용 프로그램:didFinishLaunchingWithOptions:</code>방법. 예를 들어 앱의 오디오가 음소거되었을 때 다른 앱의 오디오가 들리도록 허용하려는 경우와 같이 보다 정교한 AVAudioSession 구성이 필요한 상황이 있을 수 있습니다. 이 상황에서 현재 AVPlayer에 액세스할 수 있는 보기 컨트롤러에서 AVAudioSession을 구성할 수 있습니다. 예를 들면 다음과 같습니다.</p>

<pre><code>// Swift func setUpAudioSession() { var categoryError :NSError? var success: Bool do { if let currentPlayer = currentPlayer { // If the player is muted, then allow mixing. // Ensure other apps can have their background audio // active when this app is in foreground if currentPlayer.isMuted { try AVAudioSession.sharedInstance().setCategory(.playback, options: .mixWithOthers) } else { try AVAudioSession.sharedInstance().setCategory(.playback, options: AVAudioSession.CategoryOptions(rawValue: 0)) } } else { try AVAudioSession.sharedInstance().setCategory(.playback, options: AVAudioSession.CategoryOptions(rawValue: 0)) } success = true } catch let error as NSError { categoryError = error success = false } if !success { print("AppDelegate Debug - Error setting AVAudioSession category. Because of this, there may be no sound. \(categoryError!)") } } </code></pre>

<pre><code>// Objc-C - (void)setUpAudioSession { NSError *categoryError = nil; BOOL success; // If the player is muted, then allow mixing. // Ensure other apps can have their background audio // active when this app is in foreground if (self.currentPlayer.isMuted) { success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:AVAudioSessionCategoryOptionMixWithOthers error:&amp;categoryError]; } else { success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:0 error:&amp;categoryError]; } if (!success) { NSLog(@"AppDelegate Debug - Error setting AVAudioSession category. Because of this, there may be no sound. `%@`", categoryError); } } </code></pre>

<p>샘플 코드는<a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Player/VideoCloudBasicPlayer"> VideoCloudBasicPlayer</a>샘플 프로젝트.</p>

<p>AVAudioSession에 대해 자세히 알아볼 수 있습니다. <a href="https://developer.apple.com/documentation/avfoundation/avaudiosession">여기</a> .</p>

<h1>자주 묻는 질문<a name="FAQ"></a></h1>

<p><strong>내 콘텐츠가 이겼습니다&rsquo;짐. URL이 유효한 비디오를 가리키는지 여부를 테스트하는 쉬운 방법이 있습니까?</strong></p>

<p>콘텐츠가 MP4로 패키징된 경우 URL을 대부분의 웹 브라우저에 직접 붙여넣을 수 있으며 비디오는 재생되어야 합니다(또는 로컬에서 재생할 수 있는 파일 시스템으로 다운로드). 콘텐츠가 HLS로 패키징된 경우 QuickTime Player를 사용하여 테스트할 수 있습니다. <code>파일 -&gt; 위치 열기…</code>그리고 붙여넣기<code> .m3u8</code>재생 목록 URL 및 동영상이 재생되어야 합니다.</p>

<p><strong>오디오 트랙이 재생되는 것을 들을 수 있지만 비디오가 몇 초 동안 산발적으로 멈춥니다. 뭐&rsquo;일어나고 있습니까?</strong></p>

<p>이것은 메인 쓰레드 전용 UIKit이나 비메인 쓰레드에서 AVFoundation 메소드를 호출했을 때 나타나는 일반적인 증상입니다. 에 대한 대리자 메서드<a href="Protocols/BCOVPlaybackControllerDelegate.html"><code> BCOVPlaybackControllerDelegate</code></a>항상 메인 스레드에서 호출됩니다.</p>

<p><strong>소스를 찾을 수 없다는 메시지가 로그에 표시되는 이유는 무엇입니까?</strong></p>

<p>이 메시지는 기본 소스 선택 정책이&rsquo; t 선택할 소스를 그림. 기본 정책은 다음을 포함하는 첫 번째 소스를 선택합니다. <code>배달 방법</code> ~이다<code> kBCOVSourceDeliveryHLS</code> ( &ldquo; HLS &rdquo; ). HLS 소스를 찾을 수 없는 경우 해당 대체 동작은 다음을 포함하는 첫 번째 소스를 선택합니다. <code>배달 방법</code> ~이다<code> kBCOVSourceDeliveryMP4</code> ( &ldquo; MP4 &rdquo; ). 소스가 없는 경우<code>배달 방법</code> NS &ldquo; HLS &rdquo;또는&ldquo; MP4 &rdquo;동영상에 존재하는 경우 정책에서 동영상을 선택합니다. &rsquo;의 첫 번째 소스( <code>배달 방법</code> ). 당신이&rsquo; t 선택에 만족하면 사용할 수 있습니다. <a href="Classes/BCOVPlayerSDKManager.html#//api/name/createBasicSessionProviderWithOptions:"><code> [BCOVPlayerSDKManager createBasicSessionProviderWithOptions:]</code></a>의 인스턴스를 전달합니다. <a href="Classes/BCOVBasicSessionProviderOptions.html"><code> BCOVBasicSessionProvider 옵션</code></a>관습으로<code>소스 선택 정책</code>속성 집합입니다. 비디오 및 소스를 수동으로 만들 때 소스가 적절한<code>배달 방법</code> .</p>

<p><strong><a href="https://developer.apple.com/Library/ios/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/AudioGuidelinesByAppType/AudioGuidelinesByAppType.html">애플 추천</a>비디오를 재생하는 앱은 기기가 음소거된 경우에도 여전히 오디오를 재생해야 합니다. 왜 안&rsquo; t iOS용 Brightcove Player SDK는 이 지침을 준수합니까?</strong></p>

<p>iOS 앱에서 앱이 오디오를 내보내는지 여부를 제어하는 API는<a href="https://developer.apple.com/Library/ios/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007875-CH1-SW1"> AV오디오세션 API</a> . 오디오 세션은 앱에 대해 전역적입니다. 즉, 해당 구성은 Player SDK에서 생성된 AVPlayer에서 방출되는 사운드와 앱에서 생성할 수 있는 다른 사운드 모두에 영향을 줍니다. Player SDK는 앱이 다른 사운드에 대해 오디오 세션을 구성하려는 방식을 알 수 없으므로&rsquo; t 오디오 세션에 전혀 영향을 미치지 않습니다. 즉, 앱을 명시적으로 구성하지 않는 한&rsquo;그렇지 않으면 AVPlayer에서 내보낸 오디오를 포함하여 장치가 음소거될 때 모든 오디오를 억제하는 기본 동작을 상속합니다. Apple을 준수하려면&rsquo;오디오 재생에 관한 권장 사항에 따라 귀하(앱 개발자)는 앱에 따라 오디오 세션을 구성해야 합니다. &rsquo; s 특정 요구.</p>

<p>우리의<a href="#AVAudioSessionConfig"> AVAudioSession 구성</a>추가 정보는 이 README의 섹션을 참조하십시오.</p>

<h1>지원하다<a name="Support"></a></h1>

<p>질문이 있거나 도움이 필요하거나 피드백을 제공하려면<a href="https://supportportal.brightcove.com/s/login/">지원 포털</a>또는 계정 관리자에게 문의하세요. 새 SDK 소프트웨어 릴리스에 대한 알림을 받으려면 Brightcove Native Player SDK를 구독하십시오. <a href="https://groups.google.com/g/brightcove-native-player-sdks">구글 그룹</a> .</p>
						
						
					</div>
					

					<div class="index-container">
						

						
						<div class="index-column">
							<h2 class="index-title">클래스 참조</h2>
							<ul>
								
								<li>BCOVAd<a href="Classes/BCOVAd.html"></a></li>
								
								<li>BCOVAdSequence<a href="Classes/BCOVAdSequence.html"></a></li>
								
								<li>BCOVBasicSessionProvider<a href="Classes/BCOVBasicSessionProvider.html"></a></li>
								
								<li><a href="Classes/BCOVBasicSessionProviderOptions.html">BCOVBasicSessionProvider 옵션</a></li>
								
								<li>BCOVBasicSourceSelectionPolicy<a href="Classes/BCOVBasicSourceSelectionPolicy.html"></a></li>
								
								<li>BCOVCuePoint<a href="Classes/BCOVCuePoint.html"></a></li>
								
								<li><a href="Classes/BCOVCuePointCollection.html">BCOVCuePoint 컬렉션</a></li>
								
								<li>BCOVCuePointProgressPolicy<a href="Classes/BCOVCuePointProgressPolicy.html"></a></li>
								
								<li>BCOVCuePointProgressPolicyResult<a href="Classes/BCOVCuePointProgressPolicyResult.html"></a></li>
								
								<li>BCOVFPSBrightcoveAuthProxy<a href="Classes/BCOVFPSBrightcoveAuthProxy.html"></a></li>
								
								<li>BCOVFairPlayManager<a href="Classes/BCOVFairPlayManager.html"></a></li>
								
								<li><a href="Classes/BCOVGlobalConfiguration.html">BCOV글로벌 구성</a></li>
								
								<li>BCOVOfflineVideoManager<a href="Classes/BCOVOfflineVideoManager.html"></a></li>
								
								<li><a href="Classes/BCOVOfflineVideoStatus.html">BCOV오프라인동영상상태</a></li>
								
								<li><a href="Classes/BCOVPUIAdControlView.html">BCOVPUIAAdControlView</a></li>
								
								<li>BCOVPUIBasicControlView<a href="Classes/BCOVPUIBasicControlView.html"></a></li>
								
								<li><a href="Classes/BCOVPUIButton.html">BCOVPUI버튼</a></li>
								
								<li><a href="Classes/BCOVPUICommon.html">BCOVPUI공통</a></li>
								
								<li>BCOVPUIControlLayout<a href="Classes/BCOVPUIControlLayout.html"></a></li>
								
								<li>BCOVPUILayoutView<a href="Classes/BCOVPUILayoutView.html"></a></li>
								
								<li>BCOVPUIPlayerView<a href="Classes/BCOVPUIPlayerView.html"></a></li>
								
								<li>BCOVPUIPlayerViewOptions<a href="Classes/BCOVPUIPlayerViewOptions.html"></a></li>
								
								<li>BCOVPUISlider<a href="Classes/BCOVPUISlider.html"></a></li>
								
								<li><a href="Classes/BCOVPlaybackService.html">BCOV재생 서비스</a></li>
								
								<li>BCOVPlaybackServiceRequestFactory<a href="Classes/BCOVPlaybackServiceRequestFactory.html"></a></li>
								
								<li>BCOVPlaybackSessionLifecycleEvent<a href="Classes/BCOVPlaybackSessionLifecycleEvent.html"></a></li>
								
								<li>BCOVPlayerSDKManager<a href="Classes/BCOVPlayerSDKManager.html"></a></li>
								
								<li><a href="Classes/BCOVPlaylist.html">BCOV재생 목록</a></li>
								
								<li>BCOVPreferredBitrateConfig<a href="Classes/BCOVPreferredBitrateConfig.html"></a></li>
								
								<li><a href="Classes/BCOVSessionProviderExtension.html">BCOVSessionProvider 확장</a></li>
								
								<li><a href="Classes/BCOVSource.html">BCOV 소스</a></li>
								
								<li>BCOVTVAudioTabBarItemView<a href="Classes/BCOVTVAudioTabBarItemView.html"></a></li>
								
								<li><a href="Classes/BCOVTVCommon.html">BCOVTV공통</a></li>
								
								<li><a href="Classes/BCOVTVControlsView.html">BCOVTV제어 보기</a></li>
								
								<li>BCOVTVInfoTabBarItemView<a href="Classes/BCOVTVInfoTabBarItemView.html"></a></li>
								
								<li>BCOVTVPlayerView<a href="Classes/BCOVTVPlayerView.html"></a></li>
								
								<li><a href="Classes/BCOVTVPlayerViewOptions.html">BCOVTVPlayerView옵션</a></li>
								
								<li><a href="Classes/BCOVTVProgressView.html">BCOVTV 진행 보기</a></li>
								
								<li><a href="Classes/BCOVTVSettingsView.html">BCOVTV설정 보기</a></li>
								
								<li><a href="Classes/BCOVTVSubtitlesTabBarItemView.html">BCOVTV자막TabBarItemView</a></li>
								
								<li>BCOVTVTabBarItemView<a href="Classes/BCOVTVTabBarItemView.html"></a></li>
								
								<li><a href="Classes/BCOVUILabel.html">BCOVUI라벨</a></li>
								
								<li><a href="Classes/BCOVVideo.html">BCOV비디오</a></li>
								
								<li><a href="Classes/BCOVVideo360ViewProjection.html">BCOVVideo360View프로젝션</a></li>
								
							</ul>
						</div>
						

						
						<div class="index-column">
							
							<h2 class="index-title">프로토콜 참조</h2>
							<ul>
								
								<li><a href="Protocols/BCOVComponent.html">BCOV컴포넌트</a></li>
								
								<li><a href="Protocols/BCOVComponentIdentity.html">BCOV구성 요소 ID</a></li>
								
								<li>BCOVCuePoint<a href="Protocols/BCOVCuePoint.html"></a></li>
								
								<li><a href="Protocols/BCOVFPSAuthorizationProxy.html">BCOVFPS인증 프록시</a></li>
								
								<li>BCOVMutableAnalytics<a href="Protocols/BCOVMutableAnalytics.html"></a></li>
								
								<li><a href="Protocols/BCOVMutableCuePoint.html">BCOVMutable큐포인트</a></li>
								
								<li><a href="Protocols/BCOVMutablePlaylist.html">BCOVMutable재생 목록</a></li>
								
								<li>BCOVMutableSource<a href="Protocols/BCOVMutableSource.html"></a></li>
								
								<li><a href="Protocols/BCOVMutableVideo.html">BCOV가변동영상</a></li>
								
								<li>BCOVOfflineVideoManagerDelegate<a href="Protocols/BCOVOfflineVideoManagerDelegate.html"></a></li>
								
								<li>BCOVPUIButtonAccessibilityDelegate<a href="Protocols/BCOVPUIButtonAccessibilityDelegate.html"></a></li>
								
								<li>BCOVPUIPlayerViewDelegate<a href="Protocols/BCOVPUIPlayerViewDelegate.html"></a></li>
								
								<li><a href="Protocols/BCOVPlaybackController.html">BCOV재생 컨트롤러</a></li>
								
								<li>BCOVPlaybackControllerAdsDelegate<a href="Protocols/BCOVPlaybackControllerAdsDelegate.html"></a></li>
								
								<li>BCOVPlaybackControllerBasicDelegate<a href="Protocols/BCOVPlaybackControllerBasicDelegate.html"></a></li>
								
								<li>BCOVPlaybackControllerDelegate<a href="Protocols/BCOVPlaybackControllerDelegate.html"></a></li>
								
								<li><a href="Protocols/BCOVPlaybackSession.html">BCOV재생 세션</a></li>
								
								<li>BCOVPlaybackSessionAdsConsumer<a href="Protocols/BCOVPlaybackSessionAdsConsumer.html"></a></li>
								
								<li>BCOVPlaybackSessionBasicConsumer<a href="Protocols/BCOVPlaybackSessionBasicConsumer.html"></a></li>
								
								<li>BCOVPlaybackSessionConsumer<a href="Protocols/BCOVPlaybackSessionConsumer.html"></a></li>
								
								<li>BCOVPlaybackSessionProvider<a href="Protocols/BCOVPlaybackSessionProvider.html"></a></li>
								
								<li><a href="Protocols/BCOVPlaylist.html">BCOV재생 목록</a></li>
								
								<li><a href="Protocols/BCOVSource.html">BCOV 소스</a></li>
								
								<li>BCOVTVPlayerViewDelegate<a href="Protocols/BCOVTVPlayerViewDelegate.html"></a></li>
								
								<li><a href="Protocols/BCOVVideo.html">BCOV비디오</a></li>
								
							</ul>
							

							
							<h2 class="index-title">상수 참조</h2>
							<ul>
								
									<li><a href="Constants/BCOVBufferOptimizerMethod.html">BCOVBufferOptimizer 메서드</a></li>
								
									<li><a href="Constants/BCOVEconomics.html">BCOVE경제학</a></li>
								
									<li>BCOVOfflineVideoDownloadState<a href="Constants/BCOVOfflineVideoDownloadState.html"></a></li>
								
									<li>BCOVPUIButtonIcon<a href="Constants/BCOVPUIButtonIcon.html"></a></li>
								
									<li><a href="Constants/BCOVPUILearnMoreButtonBrowserStyle.html">BCOVPUI자세히 알아보기ButtonBrowserStyle</a></li>
								
									<li><a href="Constants/BCOVPUIScreenMode.html">BCOVPUI 화면 모드</a></li>
								
									<li>BCOVPUIVideo360NavigationMethod<a href="Constants/BCOVPUIVideo360NavigationMethod.html"></a></li>
								
									<li><a href="Constants/BCOVPUIViewTag.html">BCOVPUIView태그</a></li>
								
									<li>BCOVPlaybackServiceErrorCode<a href="Constants/BCOVPlaybackServiceErrorCode.html"></a></li>
								
									<li>BCOVProgressPolicyCuePointsToProcess<a href="Constants/BCOVProgressPolicyCuePointsToProcess.html"></a></li>
								
									<li>BCOVProgressPolicyResumePosition<a href="Constants/BCOVProgressPolicyResumePosition.html"></a></li>
								
									<li>BCOVTVIconType<a href="Constants/BCOVTVIconType.html"></a></li>
								
									<li><a href="Constants/BCOVTVPlayerType.html">BCOVTV 플레이어 유형</a></li>
								
									<li><a href="Constants/BCOVTVShowViewType.html">BCOVTV보기 유형</a></li>
								
									<li><a href="Constants/BCOVVideo360ProjectionStyle.html">BCOVVideo360프로젝션 스타일</a></li>
								
									<li>BCOVVideo360SourceFormat<a href="Constants/BCOVVideo360SourceFormat.html"></a></li>
								
									<li><a href="Constants/BCOVVideoType.html">BCOV비디오 유형</a></li>
								
							</ul>
							

							
							<h2 class="index-title">카테고리 참조</h2>
							<ul>
								
								<li><a href="Categories/NSDictionary-BCOVURLSupport.html">NSDictionary(BCOVURL지원)</a></li>
								
							</ul>
							
						</div>
						
					</div>

					<footer>
						<div class="footer-copyright">
							
							<p class="copyright">저작권&copy; 2021 브라이트코브. 판권 소유. 업데이트됨: 2021-07-08</p>
							
							
							<p class="generator">에 의해 생성 된<a href="http://appledoc.gentlebytes.com"> appledoc 2.2.1(빌드 1334)</a> .</p>
							
						</div>
					</footer>
				</main>
			</div>
		</div>
	</article>

	<script src="js/script.js"></script>
</body>
</html>
