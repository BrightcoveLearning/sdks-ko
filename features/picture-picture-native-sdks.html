
---
title: 네이티브 SDK 설명이 포함된 PIP(Picture in Picture): 이 주제에서는 Brightcove Native Player SDK를 사용하여 앱에서 PIP 모드를 구현하는 방법을 배웁니다.
parent: Features 
grandparent: Home
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

<section class="bcls-section">
<h2 id="Overview">개요</h2>

<p>PIP(Picture in Picture) 모드를 사용하면 사용자가 장치에서 멀티태스킹을 수행할 수 있습니다. 이 기능을 사용하면 사용자가 다른 작업을 수행하는 동안 작은 비디오 재생 창이 화면 모서리에 고정되는 앱을 만들 수 있습니다.</p>

<figure class="bcls-figure"><img class="bcls-image--no-border" width="600" alt="Picture in picture mode" src="/assets/images/getting-started/pip/android-steps.png" />
<figcaption class="bcls-caption--image">화면 속 화면 모드</figcaption>
</figure>
</section>

<section class="bcls-section">
<h2 id="Features">특징</h2>

<p>Brightcove Native SDK에서 제공하는 화면 속 화면 기능은 다음 기능을 지원합니다.</p>

<ul>
	<li>사용자가 제어 막대에서 PIP 아이콘을 클릭하여 PIP 모드로 전환하는 경우 개발자는 프로그래밍 방식으로 PIP 모드로 전환할 수 있습니다.</li>
	<li>사용자는 화면 모서리 주위로 PIP 창을 드래그하여 가장 편리한 위치에 배치할 수 있습니다.</li>
	<li>사용자는 PIP 창에서 비디오를 일시 중지하고 재생하거나 완전히 제거할 수 있습니다. 사용자는 인앱 경험으로 다시 비디오를 최대화할 수도 있습니다.</li>
	<li>PIP 모드는 앱, 장치 배경 및 기타 응용 프로그램 위에서 작동합니다.</li>
</ul>
</section>

<section class="bcls-section">
<h2 id="Supported_versions">지원되는 버전</h2>

<p>PIP 모드는 다음 버전에서 지원됩니다.</p>

<h3>기기 OS 버전</h3>

<ul>
	<li><strong>기계적 인조 인간:</strong> Oreo 8.0 이상(API 레벨 26 이상)</li>
	<li>iOS:<strong></strong> 10.0+</li>
</ul>

<h3>네이티브 SDK 버전</h3>

<ul>
	<li><strong>기계적 인조 인간:</strong> Android 버전 6.1.0 이상용 Brightcove 기본 SDK</li>
	<li>iOS:<strong></strong> iOS 버전 6.4.4 이상용 Brightcove 기본 SDK</li>
</ul>
</section>

<section class="bcls-section">
<h2 id="Android_implementation">안드로이드 구현</h2>

<p>다음 항목은 화면 속 화면 기능을 시작하는 데 도움이 됩니다.</p>

<ul>
	<li><a href="#Using_BrightcovePlayer">BrightcovePlayer 사용</a></li>
	<li><a href="#Using_a_regular_Activity">일반 활동 사용</a></li>
	<li><a href="#Customizing_picture_in_picture">화면 속 화면 사용자 지정</a></li>
</ul>

<p>자세한 내용은 Android의<a href="https://developer.android.com/guide/topics/ui/picture-in-picture.html">화면 속 화면 지원 가이드</a> .</p>

<h3 id="Using_BrightcovePlayer">BrightcovePlayer 사용</h3>

<p>PIP 사용을 시작하는 가장 쉬운 방법은 활동을 확장하는 것입니다. <code translate="No">BrightcovePlayer</code> . 이렇게 하려면 다음 단계를 따르세요.</p>

<ol class="bcls-tasklist">
	<li>당신의<strong>스타일.xml</strong>파일에 다음 코드를 추가하여 PIP(Picture in Picture) 버튼을 활성화합니다.

	<pre class="line-numbers">
<code class="language-xml" translate="No">&lt;style name="BrightcoveControlBar" parent="BrightcoveControlBarDefault"&gt;
    &lt;item name="brightcove_picture_in_picture"&gt;true&lt;/item&gt;
&lt;/style&gt;</code></pre>
	</li>
	<li>당신의<strong> AndroidManifest.xml</strong>파일, <a href="https://developer.android.com/guide/topics/ui/picture-in-picture.html#declaring"> PIP 지원 선언</a>다음을 추가하여 활동에 대해
	<pre class="line-numbers">
<code class="language-xml" translate="No">&lt;activity android:name="VideoActivity"
  android:resizeableActivity="true"
<span class="bcls-highlight">  android:supportsPictureInPicture="true"
  android:configChanges=
      "screenSize|smallestScreenSize|screenLayout|orientation"</span>
  ...
</code></pre>

	<p>이것은 중요한 단계입니다. 선언하지 않으면 사용자가 Brightcove Media Controller에서 PIP(Picture in Picture) 버튼을 눌렀을 때<code translate="No">IllegalStateException</code>던져질 것입니다:</p>

	<pre>
<code class="language-java" translate="No">java.lang.IllegalStateException: enterPictureInPictureMode: Current activity does not support picture in picture</code></pre>
	</li>
</ol>

<p>PIP 모드로 전환하면 활동 자체의 크기가 조정되어 PIP 창의 모든 활동 구성 요소를 유지합니다. 이를 방지하고 더 쉽게 구현하기 위해 Brightcove 비디오 보기는 PIP 창의 비디오만 표시하는 상위 레이아웃 너비 및 높이와 일치하도록 자동으로 전체 화면으로 전환됩니다. 이 모드를 종료하면 Brightcove 비디오 보기가 원래 상태로 돌아갑니다.</p>

<p>앱에서 PIP(Picture in Picture)를 원하지 않는 경우 다음 코드를 앱에 추가하여 PIP(Picture in Picture) 버튼을 비활성화할 수 있습니다. <strong>스타일.xml</strong>파일:</p>

<pre class="line-numbers">
<code class="language-xml" translate="No">&lt;style name="BrightcoveControlBar" parent="BrightcoveControlBarDefault"&gt;
    &lt;item name="brightcove_picture_in_picture"&gt;false&lt;/item&gt;
&lt;/style&gt;</code></pre>

<h3 id="Using_a_regular_Activity">일반 활동 사용</h3>

<p>확장되지 않는 활동을 사용하는 경우<code translate="No">BrightcovePlayer</code> , 이전 섹션에서 언급한 화면 속 화면 지원을 선언하는 것 외에도 몇 가지 추가 단계를 수행해야 합니다.</p>

<ol class="bcls-tasklist__restart">
	<li>열기<strong>메인 액티비티.자바</strong>파일.</li>
	<li>에서<code translate="No">onCreate</code>활동 방법, Brightcove에 활동 등록<code translate="No">PictureInPictureManager</code> :
	<pre>
<code class="language-java" translate="No">PictureInPictureManager.getInstance().registerActivity(Activity, BrightcoveVideoView)</code></pre>
	</li>
	<li>에서<code translate="No">onDestroy</code>방법, 활동 등록 취소:
	<pre>
<code class="language-java" translate="No">PictureInPictureManager.getInstance().unregisterActivity(Activity)</code></pre>
	</li>
	<li>재정의<code translate="No">onPictureInPictureModeChanged</code>활동 방법 및 호출<code translate="No">onPictureInPictureModeChanged()</code>방법은 아래와 같습니다.
	<pre class="line-numbers">
<code class="language-java" translate="No">@Override
  public void onPictureInPictureModeChanged (boolean isInPictureInPictureMode, Configuration newConfig) {
     super.onPictureInPictureModeChanged(isInPictureInPictureMode, newConfig);
     PictureInPictureManager.getInstance().onPictureInPictureModeChanged(isInPictureInPictureMode, newConfig);
  }</code></pre>
	</li>
	<li>마지막으로 재정의<code translate="No">onUserLeaveHint()</code>활동 방법 및 호출<code translate="No">onUserLeaveHint()</code>아래 그림과 같이:
	<pre class="line-numbers">
<code class="language-java" translate="No">@Override
  public void onUserLeaveHint () {
     super.onUserLeaveHint();
     PictureInPictureManager.getInstance().onUserLeaveHint();
  }</code></pre>
	</li>
</ol>

<p>이 단계를 수행하면 사진 속 화면 버튼이 Brightcove 미디어 컨트롤러에 자동으로 나타납니다. 다음과 같이 프로그래밍 방식으로 화면 속 화면을 트리거할 수도 있습니다.</p>

<pre>
<code class="language-java" translate="No">PictureInPictureManager.getInstance().enterPictureInPictureMode()</code></pre>

<aside class="bcls-aside bcls-aside--information">이 메서드를 호출하면<code translate="No">PictureInPictureManagerException</code>활동이 등록되지 않은 경우.</aside>

<h3 id="Customizing_picture_in_picture">화면 속 화면 사용자 지정</h3>

<p>PIP 창을 통해 PIP의 동작과 모양을 사용자 정의할 수 있습니다. <code translate="No">PictureInPictureManager</code> . 예를 들어 창의 종횡비를 변경하거나 비디오에 대한 캡션을 활성화/비활성화할 수 있습니다.</p>

<p>Android Oreo는 기본적으로 사용자 정의할 수 있는 세 가지 매개변수를 제공합니다.</p>

<ul>
	<li><a href="https://developer.android.com/reference/android/app/PictureInPictureParams.Builder.html#setAspectRatio(android.util.Rational)">종횡비</a>

	<pre>
<code class="language-java" translate="No">setAspectRatio(Rational)</code></pre>
	</li>
	<li><a href="https://developer.android.com/reference/android/app/PictureInPictureParams.Builder.html#setSourceRectHint(android.graphics.Rect)">소스 경계 힌트</a>
	<pre>
<code class="language-java" translate="No">setSourceRectHint(Rect)</code></pre>
	</li>
	<li><a href="https://developer.android.com/reference/android/app/PictureInPictureParams.Builder.html#setActions(java.util.List%3Candroid.app.RemoteAction%3E)">원격 작업 목록</a>
	<pre>
<code class="language-java" translate="No">setUserActions(List&lt;RemoteAction&gt;)</code></pre>
	</li>
</ul>

<h4>사용자 작업</h4>

<p>브라이트코브는<code translate="No">RemoteAction</code>기본적으로<code translate="No">Play/Pause</code>비디오 이벤트 및 해당 아이콘을 설정합니다. 즉, 기본값<code translate="No">RemoteAction</code>다음으로 설정한 원격 작업 목록에 추가됩니다.</p>

<pre>
<code class="language-java" translate="No">setUserActions</code></pre>

<p>제한된 수의 작업만 설정할 수 있습니다. 얻기 위해<a href="https://developer.android.com/reference/android/app/Activity.html#getMaxNumPictureInPictureActions()">최대 작업 수</a> , 다음을 호출합니다.</p>

<pre>
<code class="language-java" translate="No">Activity.getMaxNumPictureInPictureActions()</code></pre>

<h4>자막</h4>

<p>화면 속 화면 모드에서 비디오를 재생할 때 자막을 활성화/비활성화할 수 있습니다. <code translate="No">inPictureInPictureManager</code> .</p>

<pre>
<code class="language-java" translate="No">setClosedCaptionsEnabled(boolean)</code></pre>

<p>폐쇄 자막은 기본적으로 휴대폰에서는 비활성화되어 있지만 태블릿에서는 활성화되어 있습니다. 화면 속 화면 모드에서 재생하는 동안 자막의 크기를 줄이려면 다음을 호출하여 다음 사이의 값을 설정하십시오. <code translate="No">0</code>그리고<code translate="No">1.0f</code> .</p>

<pre>
<code class="language-java" translate="No">setClosedCaptionsReductionScaleFactor(float)</code></pre>

<p>기본적으로 화면 속 화면 모드의 자막 크기는<code translate="No">0.5f</code>또는 원래 크기의 50%입니다. 마지막으로 활동 시 사진 모드로 들어가려면<code translate="No">onUserLeaveHint()</code>가 호출되면 다음을 설정하십시오. <code translate="No">true</code> :</p>

<pre>
<code class="language-java" translate="No">setOnUserLeaveEnable(boolean)</code></pre>

<h4>매개변수</h4>

<p>현재 PIP 매개변수를 검색하기 위해 다음을 호출할 수 있습니다.</p>

<pre>
<code class="language-java" translate="No">PictureInPicture.getBrightcovePictureInPictureParams()</code></pre>

<p>이 호출은<code translate="No">BrightcovePictureInPictureParams</code>이전에 논의된 모든 매개변수에 대한 getter가 있는 개체입니다.</p>
</section>

<section class="bcls-section">
<h2 id="iOS_implementation">iOS 구현</h2>

<p>PIP(Picture in Picture)를 시작하려면 다음을 추가하십시오. <code translate="No">showPictureInPictureButton</code>에게<code translate="No">BCOVPUIPlayerViewOptions</code> . true로 설정하면 PIP(picture in picture) 버튼이 지원되는 장치의 플레이어 컨트롤에 추가됩니다.</p>
<p>사진 속 사진은 다음 중 하나입니다. <a href="https://www.apple.com/ios/ios-14/features/"> iOS 14의 새로운 기능</a> .</p>

<p>자세한 내용은 다음을 참조하세요.</p>

<ul>
	<li>NS <a href="https://github.com/brightcove/brightcove-player-sdk-ios#PIP">화면 속 화면</a> iOS용 Brightcove 네이티브 SDK 참조 섹션</li>
	<li>애플의<a href="https://developer.apple.com/documentation/avkit/adopting_picture_in_picture_in_a_custom_player">사용자 지정 플레이어에서 PIP(Picture in Picture) 채택</a>문서</li>
</ul>

<p>코드 예제는 다음을 참조하십시오. <a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Player/VideoCloudBasicPlayer">기본 비디오 재생 앱</a> .</p>
</section>

<section class="bcls-section">
<h2 id="Limitations">제한 사항</h2>

<h3>기계적 인조 인간</h3>

<ul>
	<li>PIP(Picture in Picture)는 Android Oreo 이상이 설치된 기기에서만 작동합니다.</li>
	<li>현재 Android TV에서는 지원되지 않습니다.</li>
	<li>광고가 있는 동영상은 지원되지 않습니다.</li>
	<li>360 동영상은 지원되지 않습니다</li>
</ul>

<h3>iOS</h3>

<ul>
	<li>광고가 있는 동영상은 지원되지 않습니다.</li>
	<li>360 동영상은 지원되지 않습니다</li>
</ul>
</section>

<section class="bcls-section">
<h2 id="Known_issues">알려진 문제</h2>

<h3>기계적 인조 인간</h3>

<ul>
	<li>PIP 모드에서 재생 중인 Widevine 보호 동영상은 Android 8.0이 설치된 Pixel C에서 투명하거나 검은색으로 바뀝니다. Android 8.1이 설치된 동일한 기기에서는 문제가 재현되지 않습니다.</li>
</ul>
</section>
</article>